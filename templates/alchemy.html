{% extends "includes/layout.html" %}

{% block headAdditions %}
<style>
    /* All page-specific styles have been moved to style.css for centralization. */
    @media (max-width: 768px) {
        .alchemy-card .song-artist,
        .alchemy-card .song-title {
            font-size: 16px;
        }
    }
    .alchemy-card-header .song-number {
        /* Allow the song title/artist to wrap if it's too long */
        white-space: normal;
        word-break: break-word;
        flex-shrink: 1;
        min-width: 0; /* Necessary for text wrapping in a flex container */
        line-height: 1.3; /* Adjust for better readability */
    }
    
    .type-toggle-btn {
        background: #3B82F6;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        line-height: 1.2;
        text-align: center;
        min-width: 65px;
        margin-right: 8px;
        transition: background-color 0.2s;
    }
    
    .type-toggle-btn:hover {
        background: #2563EB;
    }
    
    .item-type-artist .type-toggle-btn {
        background: #8B5CF6;
    }
    
    .item-type-artist .type-toggle-btn:hover {
        background: #7C3AED;
    }
</style>
{% endblock %}

{% block content %}
<section>
    <header class="page-header">
        <h1>AudioMuse-AI - Song Alchemy</h1>
        <p>Select tracks or artists to Include or Exclude â€” boost favorites with Include and remove unwanted flavors with Exclude.</p>
    </header>

    <form id="alchemy-form">
        <fieldset>
            <legend>Artist and/or Song Selection</legend>
            <div id="song-rows" class="param-group">
                <!-- Item cards will be injected here by JavaScript -->
            </div>
        </fieldset>

        <fieldset>
            <legend>Parameters</legend>
            <div class="param-group">
                <div>
                    <label for="n_results" class="label-with-tooltip">
                        Number of results:
                        <span class="info-tooltip" tabindex="0">
                            <span class="info-icon"></span>
                            <span class="tooltip-text">How many songs to find from your alchemy blend. Higher numbers give you more variety but may include less-similar songs. Try 100 for a full playlist, or 20-30 for a quick mix.</span>
                        </span>
                    </label>
                    <input id="n_results" name="n_results" type="number" value="100" min="1" max="200" />
                </div>
                <div>
                    <label for="temperature" class="label-with-tooltip">
                        Sampling temperature (Ï„)
                        <span class="info-tooltip" tabindex="0">
                            <span class="info-icon"></span>
                            <span class="tooltip-text">Controls randomness in song selection. 1.0 = balanced mix. Lower (0.1-0.5) = stick closer to your exact blend. Higher (1.5-3.0) = explore more unexpected songs. Like turning up the "surprise me" dial!</span>
                        </span>
                    </label>
                    <input id="temperature" name="temperature" type="number" step="0.1" min="0" max="10" value="1.0" />
                    <div style="font-size:0.85rem;color:#6B7280;margin-top:6px;">Lower = more deterministic, Higher = more random</div>
                </div>
                <div>
                    <label for="subtract_distance" class="label-with-tooltip">
                        Subtract distance threshold:
                        <span class="info-tooltip" tabindex="0">
                            <span class="info-icon"></span>
                            <span class="tooltip-text">How aggressively to exclude songs you marked as "Subtract". Lower values (0.1-0.3) = only remove very similar songs. Higher values (0.5-0.8) = remove anything remotely similar. Use this to filter out entire genres or moods you don't want.</span>
                        </span>
                    </label>
                    <div class="param-row">
                        <input id="subtract_distance" type="range" min="0" max="1" step="0.01" value="0.30" />
                        <span id="subtract_distance_label" style="font-weight: 500;">0.30</span>
                        <input id="subtract_distance_angular_input" type="number" min="0" max="1" step="0.01" value="0.30" />
                    </div>
                    <input id="subtract_distance_euclid" type="number" min="0" step="0.01" value="5.0" style="margin-top: 0.5rem;" />
                </div>
            </div>
        </fieldset>

        <div class="alchemy-controls task-buttons">
            <button id="run-alchemy" type="submit">Run Alchemy</button>
            <button id="add-row" type="button">Add Another Item</button>
        </div>
    </form>
</section>

<section id="results" class="hidden">
    <h2>Results</h2>
    <div style="position: relative; width: 100%; max-width: 800px; margin: 0 auto 1.5rem auto;">
        <canvas id="alchemy-plot"></canvas>
        <div id="projection-label" style="text-align: center; font-size:0.9rem; color:#6B7280; margin-top:0.5rem; text-transform: capitalize;"></div>
    </div>
    <div id="results-table-wrapper">
        <table id="results-table">
            <thead>
            <tr>
                <th>Title</th>
                <th>Artist</th>
                <th>Distance</th>
            </tr>
            </thead>
            <tbody id="results-list">
            </tbody>
        </table>
    </div>
</section>

<section id="playlist-creator" class="hidden">
    <h3>Create a Playlist from Results</h3>
    <form id="playlist-form">
        <div class="param-group">
            <div>
                <label for="playlist_name">Playlist Name:</label>
                <input type="text" id="playlist_name" name="playlist_name" required placeholder="e.g., My Alchemy Mix">
            </div>
        </div>
        <button type="submit" style="background-color: #16A34A;">Create Playlist on Media Server</button>
    </form>
    <div id="playlist-status"></div>
</section>
{% endblock %}

{% block bodyAdditions %}
<script>
    (async () => {
        // Fetch config to get ALCHEMY defaults
        let defaultN = 100;
        let maxN = 200;
        let cfg = {};
        try {
            const resp = await fetch("{{ url_for('get_config_endpoint') }}");
            cfg = await resp.json();
            if (cfg.alchemy_default_n_results) defaultN = cfg.alchemy_default_n_results;
            if (cfg.alchemy_max_n_results) maxN = cfg.alchemy_max_n_results;
        } catch (e) { console.warn('Failed to fetch config for alchemy, using defaults', e); }

        // Autocomplete plumbing
        let searchTimeout;
        const songRows = document.getElementById('song-rows');
        const addRowBtn = document.getElementById('add-row');

        const setupAutocomplete = (artistInputEl, titleInputEl, resultsEl, idEl, songCardEl, songNumberEl) => {
            const selectedSongNameEl = songCardEl.querySelector('.selected-song-name');

            const handleSearch = async () => {
                const artistQuery = artistInputEl.value.trim();
                const titleQuery = titleInputEl.value.trim();
                if (artistQuery.length < 2 && titleQuery.length < 2) {
                    resultsEl.classList.add('hidden');
                    return;
                }
                try {
                    const params = new URLSearchParams({ artist: artistQuery, title: titleQuery });
                    const response = await fetch(`{{ url_for('voyager_bp.search_tracks_endpoint') }}?${params}`);
                    const tracks = await response.json();
                    resultsEl.innerHTML = '';
                    if (tracks.length === 0) {
                        resultsEl.innerHTML = '<div class="autocomplete-item"><em>No results found</em></div>';
                    } else {
                        tracks.forEach(track => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'autocomplete-item';
                            itemDiv.innerHTML = `<div class="title">${track.title}</div><div class="artist">${track.author}</div>`;
                            itemDiv.addEventListener('click', () => {
                                const allIds = Array.from(document.querySelectorAll('.song-id')).map(i => i.value).filter(Boolean);
                                if (allIds.includes(track.item_id) && idEl.value !== track.item_id) {
                                    // Using a custom message box instead of alert
                                    showMessageBox('Duplicate Song', 'This song is already selected in another row.');
                                    return;
                                }
                                artistInputEl.value = track.author;
                                titleInputEl.value = track.title;
                                idEl.value = track.item_id;

                                // UPDATE: Set text content of the new dedicated span
                                selectedSongNameEl.textContent = `${track.title} â€” ${track.author}`;

                                resultsEl.classList.add('hidden');
                            });
                            resultsEl.appendChild(itemDiv);
                        });
                    }
                    resultsEl.classList.remove('hidden');
                } catch (error) {
                    console.error('Autocomplete search error:', error);
                    resultsEl.classList.add('hidden');
                }
            };

            const debouncedSearch = () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(handleSearch, 300);
            };
            artistInputEl.addEventListener('input', debouncedSearch);
            titleInputEl.addEventListener('input', debouncedSearch);
        };

        function makeRow() {
            const rowCount = document.querySelectorAll('.alchemy-card').length;
            const card = document.createElement('div');
            card.className = 'alchemy-card op-add-active item-type-song'; // Default to ADD and Song
            card.innerHTML = `
                <div class="alchemy-card-header">
                    <div class="left-group">
                        <button type="button" class="type-toggle-btn" title="Toggle Song/Artist">ðŸŽµ<br>Song</button>
                        <div class="op-buttons">
                            <button type="button" class="op-btn op-add active">Include</button>
                            <button type="button" class="op-btn op-sub">Exclude</button>
                        </div>
                        <div class="song-details-wrapper">
                            <strong class="song-number">Item ${rowCount + 1}</strong>
                            <span class="selected-song-name"></span>
                        </div>
                    </div>
                    <button type="button" class="card-close" aria-label="Remove item">&times;</button>
                </div>
                <div class="field-row">
                    <label>Artist</label>
                     <div class="autocomplete-container">
                        <input type="text" placeholder="Start typing artist..." class="song-artist" />
                        <div class="autocomplete-results-artist hidden"></div>
                    </div>
                </div>
                <div class="field-row title-field">
                    <label>Title</label>
                    <div class="autocomplete-container">
                        <input type="text" placeholder="Start typing title..." class="song-title" />
                        <div class="autocomplete-results hidden"></div>
                    </div>
                </div>
                <input type="hidden" class="song-id" />
                <input type="hidden" class="item-type" value="song" />
                <input type="hidden" class="op" value="ADD" />
            `;
            const artistInput = card.querySelector('.song-artist');
            const titleInput = card.querySelector('.song-title');
            const titleFieldRow = card.querySelector('.title-field');
            const resultsEl = card.querySelector('.autocomplete-results');
            const resultsArtistEl = card.querySelector('.autocomplete-results-artist');
            const idEl = card.querySelector('.song-id');
            const opHidden = card.querySelector('.op');
            const itemTypeHidden = card.querySelector('.item-type');
            const songNumberEl = card.querySelector('.song-number');
            const opAddBtn = card.querySelector('.op-add');
            const opSubBtn = card.querySelector('.op-sub');
            const typeToggleBtn = card.querySelector('.type-toggle-btn');
            const selectedSongNameEl = card.querySelector('.selected-song-name');

            // Type toggle handler (Song â†” Artist)
            typeToggleBtn.addEventListener('click', () => {
                if (itemTypeHidden.value === 'song') {
                    // Switch to Artist - keep artist name if present, clear title
                    const currentArtist = artistInput.value.trim();
                    itemTypeHidden.value = 'artist';
                    typeToggleBtn.innerHTML = 'ðŸŽ¤<br>Artist';
                    titleFieldRow.style.display = 'none';
                    card.classList.remove('item-type-song');
                    card.classList.add('item-type-artist');
                    titleInput.value = '';
                    idEl.value = '';
                    selectedSongNameEl.textContent = '';
                    resultsEl.classList.add('hidden');
                    resultsArtistEl.classList.add('hidden');
                    
                    // If artist name exists, trigger artist search to reload artist ID
                    if (currentArtist.length >= 2) {
                        artistInput.dispatchEvent(new Event('input'));
                    }
                } else {
                    // Switch to Song - clear everything to force fresh selection
                    itemTypeHidden.value = 'song';
                    typeToggleBtn.innerHTML = 'ðŸŽµ<br>Song';
                    titleFieldRow.style.display = '';
                    card.classList.remove('item-type-artist');
                    card.classList.add('item-type-song');
                    artistInput.value = '';
                    titleInput.value = '';
                    idEl.value = '';
                    selectedSongNameEl.textContent = '';
                    resultsEl.classList.add('hidden');
                    resultsArtistEl.classList.add('hidden');
                }
            });

            // Operation button handlers
            opAddBtn.addEventListener('click', () => {
                opHidden.value = 'ADD';
                opAddBtn.classList.add('active');
                opSubBtn.classList.remove('active');
                card.classList.add('op-add-active');
                card.classList.remove('op-subtract-active');
            });
            opSubBtn.addEventListener('click', () => {
                opHidden.value = 'SUBTRACT';
                opSubBtn.classList.add('active');
                opAddBtn.classList.remove('active');
                card.classList.add('op-subtract-active');
                card.classList.remove('op-add-active');
            });

            // Setup autocomplete for songs (existing logic)
            setupAutocomplete(artistInput, titleInput, resultsEl, idEl, card, songNumberEl);

            // Setup autocomplete for artists
            let artistSearchTimeout;
            artistInput.addEventListener('input', async () => {
                clearTimeout(artistSearchTimeout);
                const query = artistInput.value.trim();
                
                // Only show artist autocomplete when in artist mode
                if (itemTypeHidden.value !== 'artist' || query.length < 2) {
                    resultsArtistEl.classList.add('hidden');
                    return;
                }
                
                artistSearchTimeout = setTimeout(async () => {
                    try {
                        const response = await fetch(`{{ url_for('alchemy_bp.search_artists') }}?query=${encodeURIComponent(query)}`);
                        const artists = await response.json();
                        resultsArtistEl.innerHTML = '';
                        
                        if (artists.length === 0) {
                            resultsArtistEl.innerHTML = '<div class="autocomplete-item"><em>No artists found</em></div>';
                        } else {
                            artists.forEach(artist => {
                                const itemDiv = document.createElement('div');
                                itemDiv.className = 'autocomplete-item';
                                itemDiv.innerHTML = `<div class="title">${artist.artist}</div><div class="artist">${artist.track_count} tracks</div>`;
                                itemDiv.addEventListener('click', () => {
                                    artistInput.value = artist.artist;
                                    idEl.value = artist.artist_id || artist.artist;
                                    selectedSongNameEl.textContent = artist.artist;
                                    resultsArtistEl.classList.add('hidden');
                                });
                                resultsArtistEl.appendChild(itemDiv);
                            });
                        }
                        resultsArtistEl.classList.remove('hidden');
                    } catch (error) {
                        console.error('Artist autocomplete error:', error);
                        resultsArtistEl.classList.add('hidden');
                    }
                }, 300);
            });

            const closeBtn = card.querySelector('.card-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    card.remove();
                    updateNumbers();
                });
            }

            songRows.appendChild(card);
            updateNumbers();
        }

        const updateNumbers = () => {
            Array.from(document.querySelectorAll('.alchemy-card')).forEach((card, idx) => {
                const songNumberEl = card.querySelector('.song-number');
                songNumberEl.textContent = `Item ${idx + 1}`;
            });
        };

        addRowBtn.addEventListener('click', () => makeRow());
        makeRow();
        makeRow();

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-container')) {
                document.querySelectorAll('.autocomplete-results').forEach(el => el.classList.add('hidden'));
            }
        });

        const metric = ((cfg && cfg.path_distance_metric) || 'angular').toLowerCase();
        const subtractSlider = document.getElementById('subtract_distance');
        const subtractLabel = document.getElementById('subtract_distance_label');
        const subtractEuclid = document.getElementById('subtract_distance_euclid');
        const angularInput = document.getElementById('subtract_distance_angular_input');

        // Use a single slider control. For angular metric it ranges 0..1, for euclidean 0..100.
        if (metric === 'angular') {
            subtractSlider.style.display = 'block';
            angularInput.style.display = 'inline-block';
            subtractEuclid.style.display = 'none';
            subtractSlider.min = 0;
            subtractSlider.max = 1;
            subtractSlider.step = 0.01;
            const angDefault = (cfg && (cfg.alchemy_subtract_distance_angular || cfg.alchemy_subtract_distance)) || 0.3;
            subtractSlider.value = angDefault;
            angularInput.value = parseFloat(subtractSlider.value).toFixed(2);
            subtractLabel.textContent = subtractSlider.value;
        } else {
            subtractSlider.style.display = 'block';
            angularInput.style.display = 'none';
            subtractEuclid.style.display = 'none';
            subtractSlider.min = 0;
            subtractSlider.max = 100;
            subtractSlider.step = 0.1;
            const euDefault = (cfg && (cfg.alchemy_subtract_distance_euclid || cfg.alchemy_subtract_distance)) || 5.0;
            subtractSlider.value = euDefault;
            subtractLabel.textContent = subtractSlider.value;
        }

        // Keep label (and angular numeric) in sync with slider
        subtractSlider.addEventListener('input', () => {
            const val = subtractSlider.value;
            subtractLabel.textContent = val;
            if (metric === 'angular') angularInput.value = parseFloat(val).toFixed(2);
        });
        angularInput.addEventListener('input', () => {
            let v = parseFloat(angularInput.value);
            if (isNaN(v)) v = 0;
            v = Math.max(0, Math.min(1, v));
            subtractSlider.value = v;
            subtractLabel.textContent = v.toFixed(2);
        });

        const form = document.getElementById('alchemy-form');
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                const rows = [...document.querySelectorAll('.alchemy-card')];
                const items = rows.map(r => ({ 
                    id: r.querySelector('.song-id').value.trim(), 
                    op: r.querySelector('.op').value,
                    type: r.querySelector('.item-type').value
                }));
                const valid = items.filter(i => i.id);
                // Require at least one ADD item (song or artist)
                const addCount = valid.filter(i => i.op && i.op.toUpperCase() === 'ADD').length;
                if (addCount < 1) { showMessageBox('Input Error', 'Please include at least one ADD item (song or artist).'); return }

                const nInput = parseInt(document.getElementById('n_results').value || defaultN);
                const n = Math.min(nInput, maxN);
                // Read temperature from input; fallback to server config if available
                let temperature = parseFloat(document.getElementById('temperature').value || NaN);
                if (isNaN(temperature) && cfg && cfg.alchemy_temperature) temperature = cfg.alchemy_temperature;

                const payload = { items: valid, n, temperature };
                if (metric === 'angular') payload.subtract_distance = parseFloat(subtractSlider.value);
                else payload.subtract_distance = parseFloat(subtractSlider.value);

                const resp = await fetch("{{ url_for('alchemy_bp.alchemy_api') }}", { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await resp.json();

                if (data.error) { showMessageBox('API Error', data.error); return }

                const list = document.getElementById('results-list');
                list.innerHTML = ''; // Clear previous results
                // Track current result IDs so playlist creation can use them
                window.currentResultIds = [];
                if(data.results && data.results.length > 0) {
                    data.results.forEach(r => {
                        const row = document.createElement('tr');
                        const distText = (typeof r.distance === 'number') ? r.distance.toFixed(4) : 'N/A';
                        row.innerHTML = `<td>${r.title || 'N/A'}</td><td>${r.author || 'N/A'}</td><td>${distText}</td>`;
                        list.appendChild(row);
                        if (r.item_id) window.currentResultIds.push(r.item_id);
                    });
                    // Show playlist creator
                    document.getElementById('playlist-creator').classList.remove('hidden');
                    document.getElementById('playlist-status').textContent = '';
                    document.getElementById('playlist_name').value = `Alchemy: ${document.querySelector('.alchemy-card .song-title')?.value || 'Results'}`;

                    // Draw 2D plot if Chart.js is available and server returned projections
                    try {
                        const plotEl = document.getElementById('alchemy-plot');
                        if (plotEl && (data.centroid_2d || (data.results && data.results.length) || (data.filtered_out && data.filtered_out.length))) {
                            // Build datasets
                            const fullLabel = (item) => (item.title ? `${item.title} â€” ${item.author || ''}` : item.item_id);
                            const kept = (data.results || []).map(r => ({ x: r.embedding_2d ? r.embedding_2d[0] : 0, y: r.embedding_2d ? r.embedding_2d[1] : 0, label: fullLabel(r) }));
                            const removed = (data.filtered_out || []).map(r => ({ x: r.embedding_2d ? r.embedding_2d[0] : 0, y: r.embedding_2d ? r.embedding_2d[1] : 0, label: fullLabel(r) }));
                            const add_centroid = data.add_centroid_2d ? { x: data.add_centroid_2d[0], y: data.add_centroid_2d[1], label: 'ADD Centroid' } : null;
                            const subtract_centroid = data.subtract_centroid_2d ? { x: data.subtract_centroid_2d[0], y: data.subtract_centroid_2d[1], label: 'SUBTRACT Centroid' } : null;
                            
                            // Separate songs from artist components
                            const addSongs = (data.add_points || []).filter(p => !p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const addArtistComponents = (data.add_points || []).filter(p => p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const subSongs = (data.sub_points || []).filter(p => !p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const subArtistComponents = (data.sub_points || []).filter(p => p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));

                            if (window._alchemyChart) {
                                window._alchemyChart.destroy();
                            }

                            const datasets = [];
                            // Define styles for different data types
                            if (removed.length) datasets.push({
                                label: 'Removed (filtered out)',
                                data: removed,
                                backgroundColor: 'rgba(156, 163, 175, 0.5)',
                                pointStyle: 'crossRot',
                                pointRadius: 5,
                                borderWidth: 2
                            });
                            if (kept.length) datasets.push({
                                label: 'Kept (results)',
                                data: kept,
                                backgroundColor: 'rgba(59, 130, 246, 0.7)',
                                borderColor: 'rgba(37, 99, 235, 1)',
                                borderWidth: 1,
                                pointRadius: 6
                            });
                            if (add_centroid) datasets.push({
                                label: 'Add Centroid',
                                data: [add_centroid],
                                backgroundColor: 'rgba(253, 224, 71, 1)',
                                borderColor: 'rgba(234, 179, 8, 1)',
                                borderWidth: 2,
                                pointStyle: 'star',
                                pointRadius: 15
                            });
                            if (subtract_centroid) datasets.push({
                                label: 'Subtract Centroid',
                                data: [subtract_centroid],
                                backgroundColor: 'rgba(239, 68, 68, 1)',
                                borderColor: 'rgba(159, 18, 57, 1)',
                                borderWidth: 2,
                                pointStyle: 'star',
                                pointRadius: 15
                            });
                            if (addSongs.length) datasets.push({
                                label: 'Selected ADD Songs',
                                data: addSongs,
                                backgroundColor: 'rgba(34, 197, 94, 0.9)',
                                borderColor: 'rgba(22, 163, 74, 1)',
                                borderWidth: 2,
                                pointStyle: 'circle',
                                pointRadius: 10
                            });
                            if (addArtistComponents.length) datasets.push({
                                label: 'Selected ADD Artist Components',
                                data: addArtistComponents,
                                backgroundColor: 'rgba(134, 239, 172, 0.9)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                borderWidth: 2,
                                pointStyle: 'rect',
                                pointRadius: 8
                            });
                            if (subSongs.length) datasets.push({
                                label: 'Selected SUBTRACT Songs',
                                data: subSongs,
                                backgroundColor: 'rgba(239, 68, 68, 0.9)',
                                borderColor: 'rgba(220, 38, 38, 1)',
                                borderWidth: 2,
                                pointStyle: 'circle',
                                pointRadius: 10
                            });
                            if (subArtistComponents.length) datasets.push({
                                label: 'Selected SUBTRACT Artist Components',
                                data: subArtistComponents,
                                backgroundColor: 'rgba(252, 165, 165, 0.9)',
                                borderColor: 'rgba(239, 68, 68, 1)',
                                borderWidth: 2,
                                pointStyle: 'rect',
                                pointRadius: 8
                            });

                            const projLabel = document.getElementById('projection-label');
                            let xLabel = 'Dimension 1';
                            let yLabel = 'Dimension 2';
                            if (projLabel) {
                                const projectionMethod = data.projection || 'pca';
                                projLabel.textContent = `Projection Method: ${projectionMethod.replace(/_/g, ' ')}`;
                                if (projectionMethod === 'discriminant' || projectionMethod === 'aligned_add_sub') {
                                    xLabel = 'Separation Axis (Subtract <-> Add)';
                                    yLabel = 'Orthogonal Variation';
                                } else if (projectionMethod === 'pca') {
                                    xLabel = 'Principal Component 1';
                                    yLabel = 'Principal Component 2';
                                } else if (projectionMethod === 'umap') {
                                    xLabel = 'UMAP Dimension 1';
                                    yLabel = 'UMAP Dimension 2';
                                }
                            }

                            const ctx = plotEl.getContext('2d');
                            window._alchemyChart = new Chart(ctx, {
                                type: 'scatter',
                                data: { datasets },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        tooltip: {
                                            callbacks: {
                                                label: (ctx) => {
                                                    const label = ctx.raw.label || '';
                                                    const parts = label.split(' â€” ');
                                                    if (parts.length > 1) {
                                                        return [`Title: ${parts[0]}`, `Artist: ${parts.slice(1).join(' â€” ')}`];
                                                    }
                                                    return label;
                                                }
                                            },
                                            backgroundColor: '#1F2937',
                                            titleFont: { size: 14, weight: 'bold' },
                                            bodyFont: { size: 12 },
                                            padding: 10,
                                            cornerRadius: 4,
                                            displayColors: false,
                                        },
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                usePointStyle: true,
                                                padding: 20,
                                                font: {
                                                    size: 13
                                                }
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: { display: true, text: xLabel, font: { size: 14 } },
                                            grid: { color: 'rgba(229, 231, 235, 0.5)'},
                                            ticks: { font: { size: 12 } }
                                        },
                                        y: {
                                            title: { display: true, text: yLabel, font: { size: 14 } },
                                            grid: { color: 'rgba(229, 231, 235, 0.5)'},
                                            ticks: { font: { size: 12 } }
                                        }
                                    },
                                    elements: {
                                        point: {
                                            hoverRadius: (ctx) => (ctx.chart.data.datasets[ctx.datasetIndex].pointRadius || 5) + 3,
                                        }
                                    }
                                }
                            });
                        }
                    } catch (errPlot) {
                        console.warn('Failed to draw alchemy plot', errPlot);
                    }
                } else {
                     const row = document.createElement('tr');
                     row.innerHTML = `<td colspan="3" style="text-align:center;">No results found.</td>`;
                     list.appendChild(row);
                     document.getElementById('playlist-creator').classList.add('hidden');

                     // If there are no kept results but there are filtered_out/add/sub items,
                     // still draw the projection so the user can inspect filtered points.
                     try {
                        const plotEl = document.getElementById('alchemy-plot');
                        if (plotEl && (data.centroid_2d || (data.filtered_out && data.filtered_out.length) || (data.add_points && data.add_points.length) || (data.sub_points && data.sub_points.length))) {
                            const fullLabel = (item) => (item.title ? `${item.title} â€” ${item.author || ''}` : item.item_id);
                            const removed = (data.filtered_out || []).map(r => ({ x: r.embedding_2d ? r.embedding_2d[0] : 0, y: r.embedding_2d ? r.embedding_2d[1] : 0, label: fullLabel(r) }));
                            const kept = [];
                            const add_centroid = data.add_centroid_2d ? { x: data.add_centroid_2d[0], y: data.add_centroid_2d[1], label: 'ADD Centroid' } : null;
                            const subtract_centroid = data.subtract_centroid_2d ? { x: data.subtract_centroid_2d[0], y: data.subtract_centroid_2d[1], label: 'SUBTRACT Centroid' } : null;
                            
                            // Separate songs from artist components
                            const addSongs = (data.add_points || []).filter(p => !p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const addArtistComponents = (data.add_points || []).filter(p => p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const subSongs = (data.sub_points || []).filter(p => !p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));
                            const subArtistComponents = (data.sub_points || []).filter(p => p.is_artist_component).map(p => ({ x: p.embedding_2d ? p.embedding_2d[0] : 0, y: p.embedding_2d ? p.embedding_2d[1] : 0, label: fullLabel(p) }));

                            if (window._alchemyChart) {
                                window._alchemyChart.destroy();
                            }

                            const datasets = [];
                            if (removed.length) datasets.push({
                                label: 'Removed (filtered out)',
                                data: removed,
                                backgroundColor: 'rgba(156, 163, 175, 0.5)',
                                pointStyle: 'crossRot',
                                pointRadius: 5,
                                borderWidth: 2
                            });
                            if (kept.length) datasets.push({
                                label: 'Kept (results)',
                                data: kept,
                                backgroundColor: 'rgba(59, 130, 246, 0.7)',
                                borderColor: 'rgba(37, 99, 235, 1)',
                                borderWidth: 1,
                                pointRadius: 6
                            });
                            if (add_centroid) datasets.push({
                                label: 'Add Centroid',
                                data: [add_centroid],
                                backgroundColor: 'rgba(253, 224, 71, 1)',
                                borderColor: 'rgba(234, 179, 8, 1)',
                                borderWidth: 2,
                                pointStyle: 'star',
                                pointRadius: 15
                            });
                            if (subtract_centroid) datasets.push({
                                label: 'Subtract Centroid',
                                data: [subtract_centroid],
                                backgroundColor: 'rgba(239, 68, 68, 1)',
                                borderColor: 'rgba(159, 18, 57, 1)',
                                borderWidth: 2,
                                pointStyle: 'star',
                                pointRadius: 15
                            });
                            if (addSongs.length) datasets.push({
                                label: 'Selected ADD Songs',
                                data: addSongs,
                                backgroundColor: 'rgba(34, 197, 94, 0.9)',
                                borderColor: 'rgba(22, 163, 74, 1)',
                                borderWidth: 2,
                                pointStyle: 'circle',
                                pointRadius: 10
                            });
                            if (addArtistComponents.length) datasets.push({
                                label: 'Selected ADD Artist Components',
                                data: addArtistComponents,
                                backgroundColor: 'rgba(134, 239, 172, 0.9)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                borderWidth: 2,
                                pointStyle: 'rect',
                                pointRadius: 8
                            });
                            if (subSongs.length) datasets.push({
                                label: 'Selected SUBTRACT Songs',
                                data: subSongs,
                                backgroundColor: 'rgba(239, 68, 68, 0.9)',
                                borderColor: 'rgba(220, 38, 38, 1)',
                                borderWidth: 2,
                                pointStyle: 'circle',
                                pointRadius: 10
                            });
                            if (subArtistComponents.length) datasets.push({
                                label: 'Selected SUBTRACT Artist Components',
                                data: subArtistComponents,
                                backgroundColor: 'rgba(252, 165, 165, 0.9)',
                                borderColor: 'rgba(239, 68, 68, 1)',
                                borderWidth: 2,
                                pointStyle: 'rect',
                                pointRadius: 8
                            });

                            const projLabel = document.getElementById('projection-label');
                            let xLabel = 'Dimension 1';
                            let yLabel = 'Dimension 2';
                            if (projLabel) {
                                const projectionMethod = data.projection || 'pca';
                                projLabel.textContent = `Projection Method: ${projectionMethod.replace(/_/g, ' ')}`;
                                if (projectionMethod === 'discriminant' || projectionMethod === 'aligned_add_sub') {
                                    xLabel = 'Separation Axis (Subtract <-> Add)';
                                    yLabel = 'Orthogonal Variation';
                                } else if (projectionMethod === 'pca') {
                                    xLabel = 'Principal Component 1';
                                    yLabel = 'Principal Component 2';
                                } else if (projectionMethod === 'umap') {
                                    xLabel = 'UMAP Dimension 1';
                                    yLabel = 'UMAP Dimension 2';
                                }
                            }

                            const ctx = plotEl.getContext('2d');
                            window._alchemyChart = new Chart(ctx, {
                                type: 'scatter',
                                data: { datasets },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        tooltip: {
                                            callbacks: {
                                                label: (ctx) => {
                                                    const label = ctx.raw.label || '';
                                                    const parts = label.split(' â€” ');
                                                    if (parts.length > 1) {
                                                        return [`Title: ${parts[0]}`, `Artist: ${parts.slice(1).join(' â€” ')}`];
                                                    }
                                                    return label;
                                                }
                                            },
                                            backgroundColor: '#1F2937',
                                            titleFont: { size: 14, weight: 'bold' },
                                            bodyFont: { size: 12 },
                                            padding: 10,
                                            cornerRadius: 4,
                                            displayColors: false,
                                        },
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                usePointStyle: true,
                                                padding: 20,
                                                font: {
                                                    size: 13
                                                }
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: { display: true, text: xLabel, font: { size: 14 } },
                                            grid: { color: 'rgba(229, 231, 235, 0.5)'},
                                            ticks: { font: { size: 12 } }
                                        },
                                        y: {
                                            title: { display: true, text: yLabel, font: { size: 14 } },
                                            grid: { color: 'rgba(229, 231, 235, 0.5)'},
                                            ticks: { font: { size: 12 } }
                                        }
                                    },
                                    elements: {
                                        point: {
                                            hoverRadius: (ctx) => (ctx.chart.data.datasets[ctx.datasetIndex].pointRadius || 5) + 3,
                                        }
                                    }
                                }
                            });
                        }
                     } catch (errPlot) {
                        console.warn('Failed to draw alchemy plot for filtered_out-only case', errPlot);
                     }
                }
                document.getElementById('results').classList.remove('hidden');
            } catch (err) {
                console.error('Alchemy request failed', err);
                showMessageBox('Request Failed', 'Failed to run Alchemy. See console for details.');
            }
        });

        function showMessageBox(title, message) {
            const boxId = 'custom-message-box';
            document.getElementById(boxId)?.remove();
            const messageBox = document.createElement('div');
            messageBox.id = boxId;
            // Using styles from style.css for consistency where possible, with inline for positioning
            messageBox.style.cssText = 'position: fixed; top: 20px; right: 20px; background-color: #fff; color: #1F2937; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; border: 1px solid #E5E7EB; max-width: 400px; text-align: left;';
            messageBox.innerHTML = `<h3 style="font-weight: 600; margin-top:0; margin-bottom: 10px; color: #111827;">${title}</h3><p style="margin:0;">${message}</p><button style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5rem; color: #9CA3AF; cursor: pointer;" onclick="this.parentNode.remove()">&times;</button>`;
            document.body.appendChild(messageBox);
            setTimeout(() => messageBox.remove(), 5000);
        }

    })();
</script>
<script>
    // Playlist form wiring: reuse /api/create_playlist behavior from similarity.html
    (function() {
        const playlistForm = document.getElementById('playlist-form');
        const playlistStatusDiv = document.getElementById('playlist-status');
        playlistForm.addEventListener('submit', async function (event) {
            event.preventDefault();
            const playlistName = document.getElementById('playlist_name').value;
            playlistStatusDiv.className = '';
            if (!playlistName) {
                playlistStatusDiv.textContent = 'Please enter a playlist name.';
                playlistStatusDiv.className = 'status-error';
                return;
            }
            // Collect ADD song ids from the current rows (they should be added to the playlist even if not in results)
            const addIds = Array.from(document.querySelectorAll('.alchemy-card')).map(card => {
                const op = card.querySelector('.op')?.value;
                const id = card.querySelector('.song-id')?.value?.trim();
                return (op && op.toUpperCase() === 'ADD' && id) ? id : null;
            }).filter(Boolean);

            const resultIds = window.currentResultIds || [];

            // Combine ADD ids first, then results, removing duplicates while preserving order
            const seen = new Set();
            let combined = [];
            addIds.forEach(id => { if (!seen.has(id)) { seen.add(id); combined.push(id); } });
            resultIds.forEach(id => { if (id && !seen.has(id)) { seen.add(id); combined.push(id); } });

            // Minimal change: ensure final playlist length equals the requested number of results
            // If the user requested N results (input id 'n_results'), trim the combined list to N.
            try {
                const nEl = document.getElementById('n_results');
                if (nEl && nEl.value) {
                    const targetN = parseInt(nEl.value, 10);
                    if (!isNaN(targetN) && targetN > 0) {
                        combined = combined.slice(0, targetN);
                    }
                }
            } catch (e) { /* non-fatal; fall back to full combined list */ }

            if (combined.length === 0) {
                playlistStatusDiv.textContent = 'No tracks to add. Please run Alchemy or add songs to the ADD list.';
                playlistStatusDiv.className = 'status-error';
                return;
            }

            playlistStatusDiv.textContent = 'Creating playlist...';
            try {
                const response = await fetch("{{ url_for('voyager_bp.create_media_server_playlist') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playlist_name: playlistName, track_ids: combined }),
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `HTTP error! status: ${response.status}`);
                playlistStatusDiv.textContent = result.message || 'Playlist created.';
                playlistStatusDiv.className = 'status-success';
            } catch (error) {
                playlistStatusDiv.textContent = `Error: ${error.message}`;
                playlistStatusDiv.className = 'status-error';
                console.error('Playlist creation error:', error);
            }
        });
    })();
</script>
<script src="{{ url_for('static', filename='menu.js') }}"></script>
<script src="{{ url_for('static', filename='chart.js') }}"></script>
{% endblock %}