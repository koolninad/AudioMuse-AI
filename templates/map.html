{% extends "includes/layout.html" %}

{% block headAdditions %}
<script src="{{ url_for('static', filename='plotly-2.29.1.min.js') }}"></script>
<style>
    /* small style for overlay toggle icons when hidden */
    .am-overlay-hidden { opacity: 0.35 !important; filter: grayscale(60%); }
    #overlay-controls a { cursor: pointer; }
    /* responsive search inputs: wrap and shrink on small screens */
    .map-search-row { display:flex; gap:8px; align-items:flex-end; margin-left:12px; flex-wrap:wrap; }
    .map-search-row .map-search-col { display:flex; flex-direction:column; min-width:0; }
    .map-search-row .map-search-col.button-col { align-items:flex-start; }
    .map-search-input { width:220px; padding:4px; border-radius:4px; border:1px solid #d1d5db; box-sizing:border-box; }
    @media (max-width:600px) {
        .map-search-row { gap:6px; }
        .map-search-row .map-search-col { width:100%; }
        .map-search-row .map-search-col.button-col { width:auto; }
        .map-search-input { width: calc(100% - 12px); min-width:120px; font-size:13px; }
    }
</style>
{% endblock %}

{% block content %}
<section>
    <header class="page-header">
        <h1>AudioMuse-AI - Music Map</h1>
        <p>Precompute your music map with a song analysis, then explore it interactively and create your playlist</p>
    </header>
    <div class="map-controls" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <label for="map_size" class="label-with-tooltip">
            Map size:
            <span class="info-tooltip" tabindex="0">
                <span class="info-icon"></span>
                <span class="tooltip-text">How much of your library to display on the map. 25% = quick preview (faster loading). 100% = your entire library (may be slow on large collections). Start with 25-50% for exploration.</span>
            </span>
        </label>
        <div id="map_size" style="display:flex; gap:6px; align-items:center;">
            <button id="btn-pct-25" type="button" class="btn btn-primary">25%</button>
            <button id="btn-pct-50" type="button" class="btn btn-ghost">50%</button>
            <button id="btn-pct-75" type="button" class="btn btn-ghost">75%</button>
            <button id="btn-pct-100" type="button" class="btn btn-ghost">100%</button>
        </div>
        <button id="create-playlist" class="btn btn-primary">Create playlist</button>
        <button id="song-path-btn" class="btn btn-primary" disabled style="margin-left:6px;">Song Path</button>
        <button id="refresh-map" type="button" class="btn btn-ghost" title="Refresh map (clear overlays)" style="margin-left:6px;">Refresh</button>


        <div id="map-status" style="margin-left:12px;color:#6B7280"></div>
        <!-- Minimal search UI: Artist and Title (autocomplete + highlight) -->
        <div class="map-search-row">
            <div class="map-search-col">
                <label for="artist_search_map" style="font-size:12px;color:#374151">Artist</label>
                <input id="artist_search_map" class="map-search-input" type="text" placeholder="Artist name..." autocomplete="off">
                <div id="artist_autocomplete_results" class="autocomplete-results hidden" style="background:#fff;border:1px solid #e5e7eb;max-height:180px;overflow:auto;position:relative;z-index:50;"></div>
            </div>
            <div class="map-search-col">
                <label for="title_search_map" style="font-size:12px;color:#374151">Title</label>
                <input id="title_search_map" class="map-search-input" type="text" placeholder="Track title..." autocomplete="off">
                <div id="title_autocomplete_results" class="autocomplete-results hidden" style="background:#fff;border:1px solid #e5e7eb;max-height:180px;overflow:auto;position:relative;z-index:50;"></div>
            </div>
            <div class="map-search-col button-col">
                <label style="font-size:12px;color:transparent">&nbsp;</label>
                <button id="map_search_btn" class="btn btn-ghost btn-sm" type="button" style="margin-top:6px;">Search</button>
            </div>
        </div>
    </div>

    <div id="plot" style="width:100%;height:700px;"></div>
    <!-- overlay toggles: small icons (search highlight, path line, path points) placed below the map and above the legend -->
    <div id="overlay-controls" style="text-align:center;margin-top:8px;">
        <span class="overlay-item" style="display:inline-flex;align-items:center;margin-right:12px;">
            <a href="#" id="overlay-toggle-search" title="Toggle searched song" style="display:inline-flex;align-items:center;color:#111;text-decoration:none;font-size:14px;cursor:pointer;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;flex:0 0 auto;">
                    <circle cx="12" cy="12" r="6" fill="rgba(255,235,59,0.9)" stroke="#000" stroke-width="1.5" />
                </svg>
                <span class="overlay-label" style="font-size:14px;margin-left:6px;color:#374151;vertical-align:middle">search</span>
            </a>
        </span>

        <span class="overlay-item" style="display:inline-flex;align-items:center;margin-right:12px;">
            <a href="#" id="overlay-toggle-path" title="Toggle path line" style="display:inline-flex;align-items:center;color:#111;text-decoration:none;font-size:14px;cursor:pointer;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;flex:0 0 auto;">
                    <path d="M2 12 L8 8 L14 16 L22 10" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <span class="overlay-label" style="font-size:14px;margin-left:6px;color:#374151;vertical-align:middle">path</span>
            </a>
        </span>

        <span class="overlay-item" style="display:inline-flex;align-items:center;margin-right:12px;">
            <a href="#" id="overlay-toggle-points" title="Toggle path points" style="display:inline-flex;align-items:center;color:#111;text-decoration:none;font-size:14px;cursor:pointer;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;flex:0 0 auto;">
                    <circle cx="6" cy="12" r="2" fill="#333" />
                    <circle cx="12" cy="8" r="2" fill="#333" />
                    <circle cx="18" cy="14" r="2" fill="#333" />
                </svg>
                <span class="overlay-label" style="font-size:14px;margin-left:6px;color:#374151;vertical-align:middle">pts</span>
            </a>
        </span>
    </div>
    <div id="map-projection-label" style="text-align:center;color:#6B7280;margin-top:8px"></div>
    <!-- inline selection panel replaces debug panel -->
    <div id="selection-panel-inline" style="display:block; margin-top:8px; background:#fff; color:#111; border:1px solid #e6eef8; padding:8px; border-radius:6px; font-size:14px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
            <strong>Selected songs</strong>
            <div>
                <button id="selection-clear" class="btn btn-ghost btn-sm">Clear all</button>
            </div>
        </div>
        <div id="selection-list"></div>
    </div>
</section>
{% endblock %}

{% block bodyAdditions %}
<script>
async function fetchMapParam(param) {
    // param is a percent string like '25','50','75','100'
    // Always fetch fresh data from the server. Do not persist any map JSON in page memory.
    const resp = await fetch(`{{ url_for('map_bp.map_api') }}?percent=${encodeURIComponent(param)}`, {
        cache: 'no-store',
        headers: { 'Pragma': 'no-cache' }
    });
    if (!resp.ok) throw new Error('Failed to fetch map: ' + resp.status);
    // If server returned gzipped content, fetch() will transparently decode it in browsers.
    return await resp.json();
}

function topGenre(mood_vector) {
    if (!mood_vector) return 'unknown';
    try {
        // If mood_vector is already a single label (reduced earlier), return it
        if (!mood_vector.includes(':') && !mood_vector.includes(',')) return mood_vector;
        const parts = mood_vector.split(',');
        let best = null;
        for (const p of parts) {
            if (!p.includes(':')) continue;
            const [g,s] = p.split(':',2);
            const sc = parseFloat(s)||0;
            if (!best || sc > best[1]) best = [g.trim(), sc];
        }
        return best ? best[0] : 'unknown';
    } catch(e) { return 'unknown'; }
}

function colorPaletteFor(genres) {
    const base = ['#ff6b6b','#4ecdc4','#ffe66d','#a8e6cf','#ff8b94','#ffaaa5','#88d8b0','#ffd93d','#6c5ce7','#fdcb6e','#636e72','#00b894','#0984e3','#e84393','#00cec9'];
    const map = {};
    let i=0;
    for (const g of genres) { map[g] = base[i % base.length]; i++; }
    map['unknown'] = '#888888';
    return map;
}

async function loadAndPlot(n_or_pct) {
    document.getElementById('map-status').textContent = 'Loading...';
    try {
        const pct = String(n_or_pct || '25');
        const data = await fetchMapParam(pct);
    const items = data.items || [];
    // Do NOT store items or last requested percent in page memory — always re-fetch when needed.
        document.getElementById('map-projection-label').textContent = data.projection || '';

        // Build arrays and grouping
        const genres = new Set();
        const pts = items.map(it => {
            const g = topGenre(it.mood_vector);
            genres.add(g);
            return { id: String(it.item_id), x: it.embedding_2d[0], y: it.embedding_2d[1], title: it.title, artist: it.artist, genre: g };
        });
    const genreList = Array.from(genres);
        const colorMap = colorPaletteFor(genreList);
    // expose color map and genre list for client-side filtering/toggling
    window._colorMap = colorMap;
    window._genreList = genreList;
    window._hiddenGenres = window._hiddenGenres || new Set();

        // Subsample large datasets for faster rendering while preserving mapping
        // If using WebGL (scattergl) prefer to render the full set (no subsampling)
        const MAX_DISPLAY = 40000;
    // renderer is fixed to WebGL (scattergl)
    const rendererVal = 'scattergl';
        let displayPts = pts;
        if (rendererVal !== 'scattergl' && !window._mapUseFull && pts.length > MAX_DISPLAY) {
            const stride = Math.ceil(pts.length / MAX_DISPLAY);
            displayPts = pts.filter((_, i) => (i % stride) === 0);
            console.info(`Subsampling ${pts.length} -> ${displayPts.length} points (stride ${stride})`);
        }

        // Build a single trace with per-point color and customdata mapping using displayPts
        const colors = displayPts.map(p => colorMap[p.genre] || '#888');
    // include genre in hover text so hover shows [genre] title - artist
    const texts = displayPts.map(p => `${p.genre} — ${p.title} - ${p.artist}`);
        const ids = displayPts.map(p => p.id);

        // marker options tuned for WebGL performance when rendering many points
        const markerOpts = { size: 3, opacity: 0.85, line: { width: 0 }, symbol: 'circle' };

        const traces = [{
            x: displayPts.map(p => p.x),
            y: displayPts.map(p => p.y),
            text: texts,
            customdata: ids,
            ids: ids,
            mode: 'markers',
            type: 'scattergl',
            marker: Object.assign({}, markerOpts, { color: colors }),
            name: 'tracks'
        }];

    // expose mapping and points globally for handlers
    // window._plotPoints should reflect the plotted points (displayPts) so pointNumber maps correctly
    window._plotPointsFull = pts;
    window._plotPoints = displayPts; // indexed array; pointNumber corresponds to index in this array
    // click behavior: clicks always add the clicked point to the selection
        window._plotTracePointIdMap = null; // not needed with single-trace customdata mapping

    // render a compact, clickable legend manually (click genre to hide/show)
    const legendDiv = document.getElementById('map-projection-label');
    // Build a small control set (Hide all / Show all) and the genre items. Each genre span includes a data-genre attribute
    // so we can update its style when hidden.
    const controlsHtml = `<span style="margin-right:12px;font-size:14px;color:#6B7280"><a href="#" onclick="hideAllGenres();return false;">Hide all</a> &nbsp;|&nbsp; <a href="#" onclick="showAllGenres();return false;">Show all</a></span>`;
    const genreHtml = genreList.slice(0,50).map(g => {
        const enc = encodeURIComponent(g);
        const swatch = `<span style=\"display:inline-block;width:12px;height:12px;background:${colorMap[g]};margin-right:6px;vertical-align:middle;border-radius:2px\"></span>`;
        // allow initial hidden state styling
        const hidden = (window._hiddenGenres && window._hiddenGenres.has(g)) ? 'text-decoration:line-through' : '';
        return `<span class=\"genre-item\" data-genre=\"${enc}\" onclick=\"toggleGenre('${enc}')\" style=\"margin-right:8px;cursor:pointer;${hidden}\">${swatch}${g}</span>`;
    }).join('');
    legendDiv.innerHTML = controlsHtml + genreHtml;
    // Apply final legend styles in case window._hiddenGenres was set
    applyLegendStyles();

        const layout = {
            hovermode: 'closest',
            dragmode: 'lasso',
            legend: { orientation: 'h' },
            margin: { t: 8 }
        };

        // remove any leftover GUI 'selections' state that Plotly.react may choke on
        const gd = document.getElementById('plot');
        try { if (gd && gd.layout && gd.layout.selections) delete gd.layout.selections; } catch(e) {}

    const LARGE = 30000;
        // For very large datasets, prefer WebGL and newPlot for performance
        if (pts.length > LARGE) {
            // force WebGL renderer for large N
            traces[0].type = 'scattergl';
            // leave hover enabled so users can see genre/title/artist on hover
            traces[0].hovertemplate = '%{text}<extra></extra>';
            // reduce marker complexity further for very large N
            traces[0].marker = Object.assign({}, traces[0].marker, { sizemode: 'area' });
            // purge previous plot state to avoid GUI warnings
            try { Plotly.purge(gd); } catch(e) {}
            var plotPromise = Plotly.newPlot('plot', traces, layout, {responsive: true});
        } else {
            var plotPromise = Plotly.react('plot', traces, layout, {responsive: true});
        }

        plotPromise.then(() => {
            const gd = document.getElementById('plot');
            console.debug('Plotly.react finished. traces:', traces.length, 'points:', pts.length);
            try {
                if (gd && gd.data && gd.data[0] && gd.data[0].customdata) {
                    console.debug('customdata sample:', gd.data[0].customdata.slice(0,10));
                    if (gd.data[0].customdata.length !== pts.length) {
                        console.warn('customdata length mismatch', gd.data[0].customdata.length, 'vs pts', pts.length);
                    }
                }
            } catch(e) { console.warn('debug customdata failed', e); }
            // reset selection state when a new plot loads
            window._plotSelection = [];
            // attach handlers to the freshly rendered plot to ensure events fire
            // ensure dragmode is select/lasso so user can box/lasso select without changing toolbar
            try { Plotly.relayout(gd, {dragmode: 'lasso'}); } catch(e) {}
            attachPlotHandlers(gd);
            // update status with customdata info
            try {
                const cdlen = (gd.data && gd.data[0] && gd.data[0].customdata) ? gd.data[0].customdata.length : 0;
                document.getElementById('map-status').textContent = `Showing ${pts.length} songs — customdata ${cdlen}`;
            } catch(e) {}
        }).catch((e)=>{
            console.warn('Plotly.react promise rejected', e);
        });

        // expose current count
        document.getElementById('map-status').textContent = `Showing ${items.length} songs`;
    } catch (e) {
        console.error(e);
        document.getElementById('map-status').textContent = 'Failed to load map';
    }
}

// Toggle a genre's visibility. Called by clicks on the manual legend.
function toggleGenre(encodedGenre) {
    try {
        const g = decodeURIComponent(encodedGenre);
        window._hiddenGenres = window._hiddenGenres || new Set();
        if (window._hiddenGenres.has(g)) window._hiddenGenres.delete(g); else window._hiddenGenres.add(g);
        applyGenreFilterAndRerender();
        applyLegendStyles();
    } catch (e) { console.warn('toggleGenre failed', e); }
}

function hideAllGenres() {
    window._hiddenGenres = new Set(window._genreList || []);
    applyGenreFilterAndRerender();
    applyLegendStyles();
}

function showAllGenres() {
    window._hiddenGenres = new Set();
    applyGenreFilterAndRerender();
    applyLegendStyles();
}

function applyLegendStyles() {
    try {
        const legendDiv = document.getElementById('map-projection-label');
        if (!legendDiv) return;
        const hidden = window._hiddenGenres || new Set();
        const nodes = legendDiv.querySelectorAll('.genre-item');
        nodes.forEach(node => {
            try {
                const enc = node.getAttribute('data-genre');
                const g = decodeURIComponent(enc);
                if (hidden.has(g)) {
                    node.style.textDecoration = 'line-through';
                    node.style.opacity = '0.5';
                } else {
                    node.style.textDecoration = '';
                    node.style.opacity = '1';
                }
            } catch(e) { /* ignore */ }
        });
    } catch(e) { console.warn('applyLegendStyles failed', e); }
}

// Rebuild the displayed plot from the full points array applying hidden-genre filters
function applyGenreFilterAndRerender() {
    const ptsAll = window._plotPointsFull || [];
    const hidden = window._hiddenGenres || new Set();
    // filter out hidden genres
    let pts = ptsAll.filter(p => !hidden.has(p.genre));
    // respect subsampling policy: if not using scattergl and not _mapUseFull, subsample
    const rendererVal = 'scattergl';
    const MAX_DISPLAY = 40000;
    if (rendererVal !== 'scattergl' && !window._mapUseFull && pts.length > MAX_DISPLAY) {
        const stride = Math.ceil(pts.length / MAX_DISPLAY);
        pts = pts.filter((_, i) => (i % stride) === 0);
    }
    // rebuild trace data
    const colorMap = window._colorMap || {};
    const colors = pts.map(p => colorMap[p.genre] || '#888');
    // include genre in hover text so hover shows [genre] title - artist
    const texts = pts.map(p => `${p.genre} — ${p.title} - ${p.artist}`);
    const ids = pts.map(p => p.id);
    const markerOpts = { size: 3, opacity: 0.85, line: { width: 0 }, symbol: 'circle' };
    const trace = {
        x: pts.map(p => p.x),
        y: pts.map(p => p.y),
        text: texts,
        customdata: ids,
        ids: ids,
        mode: 'markers',
        type: rendererVal === 'scattergl' ? 'scattergl' : 'scatter',
        marker: Object.assign({}, markerOpts, { color: colors }),
        name: 'tracks'
    };
    const LARGE = 30000;
    const gd = document.getElementById('plot');
    try { if (gd && gd.layout && gd.layout.selections) delete gd.layout.selections; } catch(e) {}
    // Capture existing layout shapes so we can restore overlays (search highlight, path shapes)
    let preservedShapes = [];
    try {
        if (gd && gd.layout && Array.isArray(gd.layout.shapes)) {
            preservedShapes = gd.layout.shapes.slice();
        }
    } catch(e) { preservedShapes = []; }
    try {
        // capture current axis ranges so we don't auto-rescale or recenter the map when filtering
        let keepRanges = {};
        try {
            const curX = (gd.layout && gd.layout.xaxis && gd.layout.xaxis.range) ? gd.layout.xaxis.range : (gd._fullLayout && gd._fullLayout.xaxis && gd._fullLayout.xaxis.range ? gd._fullLayout.xaxis.range : null);
            const curY = (gd.layout && gd.layout.yaxis && gd.layout.yaxis.range) ? gd.layout.yaxis.range : (gd._fullLayout && gd._fullLayout.yaxis && gd._fullLayout.yaxis.range ? gd._fullLayout.yaxis.range : null);
            if (curX && curY) {
                keepRanges = { xaxis: { range: Array.isArray(curX) ? curX.slice() : curX, autorange: false }, yaxis: { range: Array.isArray(curY) ? curY.slice() : curY, autorange: false } };
            }
        } catch(e) { /* ignore range capture errors */ }

        const baseLayout = Object.assign({ hovermode: 'closest', dragmode: 'lasso', legend:{orientation:'h'}, margin:{t:8} }, keepRanges);

        if (pts.length > LARGE) {
            trace.type = 'scattergl';
            trace.hovertemplate = '%{text}<extra></extra>';
            trace.marker = Object.assign({}, trace.marker, { sizemode: 'area' });
            Plotly.purge(gd);
            Plotly.newPlot('plot', [trace], baseLayout, {responsive:true}).then(() => {
                // restore shape overlays after main plot is ready
                try { if (preservedShapes.length) Plotly.relayout(gd, { shapes: preservedShapes }); } catch(e) {}
                attachPlotHandlers(gd); window._plotPoints = pts; document.getElementById('map-status').textContent = `Showing ${pts.length} songs (filtered)`;
            });
        } else {
            Plotly.react('plot', [trace], baseLayout, {responsive:true}).then(() => {
                try { if (preservedShapes.length) Plotly.relayout(gd, { shapes: preservedShapes }); } catch(e) {}
                attachPlotHandlers(gd); window._plotPoints = pts; document.getElementById('map-status').textContent = `Showing ${pts.length} songs (filtered)`;
            });
        }
    } catch (e) { console.warn('applyGenreFilterAndRerender failed', e); }
}

function setActivePctButton(activeId) {
    ['btn-pct-25','btn-pct-50','btn-pct-75','btn-pct-100'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (id === activeId) { el.classList.remove('btn-ghost'); el.classList.add('btn-primary'); }
        else { el.classList.remove('btn-primary'); el.classList.add('btn-ghost'); }
    });
}

document.getElementById('btn-pct-25').addEventListener('click', () => { setActivePctButton('btn-pct-25'); loadAndPlot('25'); });
document.getElementById('btn-pct-50').addEventListener('click', () => { setActivePctButton('btn-pct-50'); loadAndPlot('50'); });
document.getElementById('btn-pct-75').addEventListener('click', () => { setActivePctButton('btn-pct-75'); loadAndPlot('75'); });
document.getElementById('btn-pct-100').addEventListener('click', () => { setActivePctButton('btn-pct-100'); loadAndPlot('100'); });

// toggle-debug button removed; no-op

// Render a selection panel listing selected songs with per-item REMOVE buttons
function findPointById(id) {
    id = String(id);
    const full = window._plotPointsFull || [];
    for (const p of full) if (String(p.id) === id) return p;
    const partial = window._plotPoints || [];
    for (const p of partial) if (String(p.id) === id) return p;
    return null;
}

function renderSelectionPanel() {
    const panel = document.getElementById('selection-panel-inline');
    const list = document.getElementById('selection-list');
    if (!panel || !list) return;
    const sel = Array.from(new Set(window._plotSelection || []));
    list.innerHTML = '';
    if (sel.length === 0) {
        list.innerHTML = '<div style="color:#666">No songs selected.</div>';
    } else {
        for (const id of sel) {
            const p = findPointById(id) || { id: id, genre: 'unknown', title: '(unknown)', artist: '' };
            const row = document.createElement('div');
            row.className = 'selection-list-item';
            const left = document.createElement('div');
            left.innerHTML = `<span style="color:#666;margin-right:6px">[${p.genre}]</span> ${p.title} - ${p.artist}`;
            const btn = document.createElement('button'); btn.className = 'btn btn-danger btn-sm'; btn.textContent = 'REMOVE'; btn.style.marginLeft = '8px'; btn.onclick = (()=>{
                return function() { removeFromSelection(id); };
            })();
            row.appendChild(left);
            row.appendChild(btn);
            list.appendChild(row);
        }
    }
    panel.style.display = 'block';
}

function removeFromSelection(id) {
    const sel = window._plotSelection || [];
    const idx = sel.indexOf(id);
    if (idx !== -1) sel.splice(idx, 1);
    window._plotSelection = sel;
    renderSelectionPanel();
    document.getElementById('map-status').textContent = `Selected ${ (window._plotSelection||[]).length } songs`;
}

// selection panel is always visible now. Attach global handler for Clear all so it always works
    try {
        const clearBtnGlobal = document.getElementById('selection-clear');
        if (clearBtnGlobal) clearBtnGlobal.onclick = () => {
            // clear selection only (do NOT remove overlays; Refresh will remove overlays)
            window._plotSelection = [];
            renderSelectionPanel();
            document.getElementById('map-status').textContent = 'Selected 0 songs';
        };
        // wire the three overlay toggle buttons (minimal wiring)
        try {
            const b1 = document.getElementById('overlay-toggle-points'); if (b1) b1.addEventListener('click', (ev)=>{ ev.preventDefault(); togglePathPoints(); });
            const b2 = document.getElementById('overlay-toggle-path'); if (b2) b2.addEventListener('click', (ev)=>{ ev.preventDefault(); togglePathLine(); });
            const b3 = document.getElementById('overlay-toggle-search'); if (b3) b3.addEventListener('click', (ev)=>{ ev.preventDefault(); toggleSearchHighlight(); });
        } catch(e) { console.warn('overlay toggle init failed', e); }
    } catch(e) { console.warn('attach global clear failed', e); }

// toggle-select removed; dragmode is forced to 'lasso' on plot render

// 'Full' toggle removed; default behavior uses subsampling policy and WebGL renderer

// Refresh button fully reloads the map to initial state: clears selection, overlays, and re-fetches data
document.getElementById('refresh-map').addEventListener('click', () => {
    try {
        // Clear all transient state
        window._plotSelection = [];
        window._mapOverlayShapes = [];
        window._mapOverlaysVisible = true;
        window._am_shapes_saved = {};
        window._am_show_flags = {};
        
        // Determine which percent button is active
        let activePct = '25';
        try {
            if (document.getElementById('btn-pct-50')?.classList.contains('btn-primary')) activePct = '50';
            else if (document.getElementById('btn-pct-75')?.classList.contains('btn-primary')) activePct = '75';
            else if (document.getElementById('btn-pct-100')?.classList.contains('btn-primary')) activePct = '100';
        } catch (e) { /* default to 25% */ }
        
        // Update the selection panel to reflect the cleared state
        try { renderSelectionPanel(); } catch(e) { /* ignore */ }
        
        // Fully reload the map with fresh data
        document.getElementById('map-status').textContent = 'Refreshing map...';
        loadAndPlot(activePct);
    } catch (e) { console.warn('refresh-map failed', e); }
});

// Prevent bfcache from preserving large in-memory map state across navigation.
window.addEventListener('pageshow', (event) => {
    try {
        if (event.persisted) {
            // Clear transient objects and re-fetch fresh map data
            window._plotPointsFull = null;
            window._plotPoints = null;
            window._plotSelection = [];
            window._colorMap = null;
            window._genreList = null;
            window._hiddenGenres = new Set();
            // re-fetch the active percent (derive from active button)
            let pct = '25';
            try {
                if (document.getElementById('btn-pct-50')?.classList.contains('btn-primary')) pct = '50';
                else if (document.getElementById('btn-pct-75')?.classList.contains('btn-primary')) pct = '75';
                else if (document.getElementById('btn-pct-100')?.classList.contains('btn-primary')) pct = '100';
            } catch (e) {}
            loadAndPlot(pct);
        }
    } catch (e) { console.warn('pageshow handler failed', e); }
});

window.addEventListener('beforeunload', () => {
    try {
        window._plotPointsFull = null;
        window._plotPoints = null;
        window._plotSelection = null;
        window._colorMap = null;
        window._genreList = null;
        window._hiddenGenres = null;
    } catch (e) { /* ignore */ }
});

// Click mode toggle: Add (default) vs Replace

// Optional: load 25% on open (default)
window.addEventListener('load', () => { setActivePctButton('btn-pct-25'); loadAndPlot('25'); });

</script>

<script>
// Minimal autocomplete and highlight logic for map search controls (connected artist+title + single Search)
(function(){
    let selectedItemId = null;

    function debounce(fn, wait){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }

    async function searchTracks(params){
        try{
            const qs = new URLSearchParams(params);
            const resp = await fetch(`{{ url_for('voyager_bp.search_tracks_endpoint') }}?${qs.toString()}`);
            if (!resp.ok) return [];
            return await resp.json();
        } catch(e){ console.debug('searchTracks failed', e); return []; }
    }

    function showResults(list, containerId){
        const c = document.getElementById(containerId);
        if (!c) return;
        c.innerHTML = '';
        if (!list || list.length === 0){ c.innerHTML = '<div style="padding:6px;color:#666">No results</div>'; c.classList.remove('hidden'); return; }
        for (const t of list.slice(0,50)){
            const div = document.createElement('div');
            div.className = 'autocomplete-item';
            div.style.padding = '6px'; div.style.cursor = 'pointer'; div.style.borderBottom = '1px solid #f3f4f6';
            div.innerHTML = `<div style="font-weight:600">${t.title || '(unknown)'}</div><div style="font-size:12px;color:#6b7280">${t.author || ''}</div>`;
            div.addEventListener('click', ()=>{
                // When an item is selected from either artist or title list, fill both fields and set the single selectedItemId
                selectedItemId = t.item_id;
                const a = document.getElementById('artist_search_map');
                const ti = document.getElementById('title_search_map');
                if (a) a.value = t.author || '';
                if (ti) ti.value = t.title || '';
                // hide both result containers
                try { document.getElementById('artist_autocomplete_results').classList.add('hidden'); } catch(e){}
                try { document.getElementById('title_autocomplete_results').classList.add('hidden'); } catch(e){}
                // NOTE: do NOT add to selection here — user requested adding only when tapping the Search button
            });
            c.appendChild(div);
        }
        c.classList.remove('hidden');
    }

    const handleArtistInput = debounce(async ()=>{
        const artistQ = document.getElementById('artist_search_map').value.trim();
        const titleQ = document.getElementById('title_search_map').value.trim();
        if (artistQ.length < 2 && titleQ.length < 2){ document.getElementById('artist_autocomplete_results').classList.add('hidden'); return; }
        const list = await searchTracks({ artist: artistQ, title: titleQ, n: 50 });
        showResults(list, 'artist_autocomplete_results');
    }, 250);

    const handleTitleInput = debounce(async ()=>{
        const artistQ = document.getElementById('artist_search_map').value.trim();
        const titleQ = document.getElementById('title_search_map').value.trim();
        if (artistQ.length < 2 && titleQ.length < 2){ document.getElementById('title_autocomplete_results').classList.add('hidden'); return; }
        const list = await searchTracks({ artist: artistQ, title: titleQ, n: 50 });
        showResults(list, 'title_autocomplete_results');
    }, 250);

    function removeExistingHighlight(){
        try {
            const gd = document.getElementById('plot');
            if (!gd) return;
            // remove any previously added highlight shapes (our highlight uses fillcolor '#ffeb3b', line black, layer 'above')
            try {
                const shapes = (gd.layout && Array.isArray(gd.layout.shapes)) ? gd.layout.shapes.slice() : [];
                const filtered = shapes.filter(s => {
                    if (!s || s.type !== 'circle' || !s.line || String(s.line.color) !== 'black' || s.layer !== 'above') return true;
                    const fc = String(s.fillcolor || '').toLowerCase();
                    // match old hex '#ffeb3b' or rgba variant starting with 'rgba(255,235,59'
                    if (fc === '#ffeb3b') return false;
                    if (fc.indexOf('rgba(255,235,59') === 0) return false;
                    return true;
                });
                if (filtered.length !== shapes.length) {
                    Plotly.relayout(gd, { shapes: filtered }).catch(()=>{});
                }
            } catch(e) {}
            // also remove any old scatter traces named 'search-highlight' just in case
            try {
                if (gd && gd.data) {
                    const toRemove = [];
                    for (let i = 0; i < gd.data.length; i++){
                        const t = gd.data[i];
                        if (!t) continue;
                        if (String(t.name || '').toLowerCase() === 'search-highlight') toRemove.push(i);
                    }
                    if (toRemove.length) Plotly.deleteTraces(gd, toRemove);
                }
            } catch(e) {}
        } catch(e) { /* ignore */ }
    }

    function addHighlightOverlay(id){
        try {
            const p = findPointById(id);
            if (!p || p.x === undefined || p.y === undefined) return false;
            const gd = document.getElementById('plot');
            if (!gd) return false;
            // remove existing highlight overlays
            removeExistingHighlight();
            // compute a radius relative to current axis ranges so the circle scales when zooming
            let xRange = null, yRange = null;
            try { xRange = (gd.layout && gd.layout.xaxis && gd.layout.xaxis.range) ? gd.layout.xaxis.range : (gd._fullLayout && gd._fullLayout.xaxis && gd._fullLayout.xaxis.range ? gd._fullLayout.xaxis.range : null); } catch(e) { xRange = null; }
            try { yRange = (gd.layout && gd.layout.yaxis && gd.layout.yaxis.range) ? gd.layout.yaxis.range : (gd._fullLayout && gd._fullLayout.yaxis && gd._fullLayout.yaxis.range ? gd._fullLayout.yaxis.range : null); } catch(e) { yRange = null; }
            // use same sizing as path points (relative fraction of axis range)
            // user requested size to be HALF of previous value: 0.015 -> 0.0075, fallback 0.3 -> 0.15
            const rx = (xRange && xRange[1] - xRange[0]) ? (xRange[1] - xRange[0]) * 0.0075 : 0.15;
            const ry = (yRange && yRange[1] - yRange[0]) ? (yRange[1] - yRange[0]) * 0.0075 : 0.15;
            const shape = {
                type: 'circle', xref: 'x', yref: 'y',
                x0: p.x - rx, x1: p.x + rx, y0: p.y - ry, y1: p.y + ry,
                // semi-transparent yellow so the underlying song marker remains visible
                fillcolor: 'rgba(255,235,59,0.35)', opacity: 0.95, line: { color: 'black', width: 3 }, layer: 'above',
                // custom marker so we can toggle it separately
                am_type: 'search-highlight'
            };
            // register the overlay shape and add it only if overlays are visible
            try { registerOverlayShapes([shape]); } catch(e) {}
            try {
                if (window._mapOverlaysVisible) {
                    const existing = (gd.layout && Array.isArray(gd.layout.shapes)) ? gd.layout.shapes.slice() : [];
                    existing.push(shape);
                    Plotly.relayout(gd, { shapes: existing }).catch(()=>{});
                }
            } catch(e) { /* ignore */ }
            return true;
        } catch(e) { console.warn('addHighlightOverlay failed', e); return false; }
    }

    function highlightSongById(id){
        if (!id) return;
        const p = findPointById(id);
        if (!p){ document.getElementById('map-status').textContent = 'Song not present on the current map (try a different percent)'; return; }
    // Do NOT automatically add highlighted song to the selection list here.
    // Selection should only be modified when the user explicitly taps the Search button
    // or clicks on the map. We still show the highlight overlay and center the view.

        // add a prominent overlay marker for the single point
        try { addHighlightOverlay(id); } catch(e) { /* ignore */ }

        // Do NOT auto-zoom or pan the map on search; only show the highlight overlay per user request.
        document.getElementById('map-status').textContent = `Highlighted: ${p.title || ''} — ${p.artist || ''}`;
    }

    // Wire inputs/buttons
    try{
        document.getElementById('artist_search_map').addEventListener('input', handleArtistInput);
        document.getElementById('title_search_map').addEventListener('input', handleTitleInput);
        document.getElementById('map_search_btn').addEventListener('click', async ()=>{
            // If user selected an item from autocomplete, use it. Otherwise run a combined search and pick first.
            if (selectedItemId) {
                try { if (!window._plotSelection) window._plotSelection = []; if (!window._plotSelection.includes(String(selectedItemId))) window._plotSelection.push(String(selectedItemId)); renderSelectionPanel(); } catch(e){}
                highlightSongById(selectedItemId);
                return;
            }
            const artistQ = document.getElementById('artist_search_map').value.trim();
            const titleQ = document.getElementById('title_search_map').value.trim();
            if (artistQ.length < 1 && titleQ.length < 1) { document.getElementById('map-status').textContent = 'Enter artist or title to search'; return; }
            const list = await searchTracks({ artist: artistQ, title: titleQ, n: 20 });
            if (!list || list.length === 0) { document.getElementById('map-status').textContent = 'No matches found'; return; }
            const t = list[0];
            // set fields and selected id
            selectedItemId = t.item_id;
            document.getElementById('artist_search_map').value = t.author || '';
            document.getElementById('title_search_map').value = t.title || '';
            // add to selection and highlight (Search click triggers add)
            try { if (!window._plotSelection) window._plotSelection = []; if (!window._plotSelection.includes(String(t.item_id))) window._plotSelection.push(String(t.item_id)); renderSelectionPanel(); } catch(e){}
            highlightSongById(t.item_id);
        });
        // clicking outside should hide results
        document.addEventListener('click', (e)=>{
            if (!e.target.closest('#artist_search_map') && !e.target.closest('#artist_autocomplete_results')) document.getElementById('artist_autocomplete_results').classList.add('hidden');
            if (!e.target.closest('#title_search_map') && !e.target.closest('#title_autocomplete_results')) document.getElementById('title_autocomplete_results').classList.add('hidden');
        });
    } catch(e){ console.warn('map search init failed', e); }
})();
</script>

<script>
// Global Plotly event handlers: collect selection and clicks, robust mapping via customdata or trace->point map
const plotElGlobal = document.getElementById('plot');
function extractIdsFromPoints(points) {
    const ids = [];
    if (!points) return ids;
    for (const p of points) {
        console.debug('extractIdsFromPoints point:', p);
        if (p.customdata !== undefined && p.customdata !== null) { ids.push(String(p.customdata)); continue; }
        // check multiple index fields that different Plotly builds use
        const idx = (p.pointIndex !== undefined) ? p.pointIndex : ((p.pointNumber !== undefined) ? p.pointNumber : (p.index !== undefined ? p.index : null));
        if (idx !== null) {
            // prefer data.customdata if present
            if (p.data && p.data.customdata && p.data.customdata[idx] !== undefined && p.data.customdata[idx] !== null) {
                ids.push(String(p.data.customdata[idx]));
                continue;
            }
            // fallback to global points array
            if (window._plotPoints && window._plotPoints[idx] && window._plotPoints[idx].id !== undefined) {
                ids.push(String(window._plotPoints[idx].id));
                continue;
            }
            // fallback to gd.data[0].customdata if available
            try {
                const gd = document.getElementById('plot');
                if (gd && gd.data && gd.data[0] && gd.data[0].customdata && gd.data[0].customdata[idx] !== undefined) {
                    ids.push(String(gd.data[0].customdata[idx]));
                    continue;
                }
            } catch(e) { /* ignore */ }
        }
    }
    if (ids.length === 0) console.debug('extractIdsFromPoints produced no ids for points', points);
    return ids;
}

function attachPlotHandlers(gd) {
    if (!gd) return;
    try {
        // detach previous handlers if present
        if (gd._amy_handlers_attached) {
            gd.removeAllListeners && gd.removeAllListeners();
        }
    } catch(e) { /* ignore */ }

    // attach fresh handlers
    try {
        const bind = (type, fn) => {
            if (typeof gd.on === 'function') {
                gd.on(type, fn);
            } else if (typeof gd.addEventListener === 'function') {
                gd.addEventListener(type, fn);
            } else if (window.Plotly && typeof window.Plotly.on === 'function') {
                window.Plotly.on(gd, type, fn);
            } else {
                throw new Error('No supported event binding found on plot element');
            }
        };

        bind('plotly_selected', (ev) => {
            // Lasso/box selection should only ADD to the existing selection, never remove.
            // Cap the number of items added at once to avoid UI/DOM overload (1000 per selection event)
            console.debug('plotly_selected event (add-only, capped)', ev && ev.points && ev.points.length, ev);
            const ids = extractIdsFromPoints(ev && ev.points).filter(Boolean);
            if (!ids || ids.length === 0) return;
            window._plotSelection = window._plotSelection || [];
            const existingSet = new Set(window._plotSelection.map(String));
            const MAX_ADD = 1000;
            let added = 0;
            const space = Math.max(0, MAX_ADD - window._plotSelection.length);
            for (const id of ids) {
                if (added >= space) break;
                const sid = String(id);
                if (!existingSet.has(sid)) {
                    window._plotSelection.push(sid);
                    existingSet.add(sid);
                    added++;
                }
            }
            if (ids.length > added) {
                document.getElementById('map-status').textContent = `Selected ${window._plotSelection.length} songs (first ${added} added; selection capped at 1000)`;
            } else {
                document.getElementById('map-status').textContent = `Selected ${window._plotSelection.length} songs`;
            }
            updateSongPathButtonState();
            // refresh inline panel so user sees newly added items
            try { renderSelectionPanel(); } catch(e) { /* ignore */ }
        });

        bind('plotly_click', (ev) => {
            console.debug('plotly_click event', ev && ev.points && ev.points[0], ev);
            const pt = ev && ev.points && ev.points[0];
            const ids = extractIdsFromPoints(pt ? [pt] : []);
            if (!ids || ids.length === 0) return;
            const id = String(ids[0]);
            window._plotSelection = window._plotSelection || [];
            // Always add clicked id to selection (do not remove/toggle here). Use inspect/remove to remove.
            if (!window._plotSelection.includes(id)) window._plotSelection.push(id);
            console.debug('toggled selection', id, window._plotSelection);
            document.getElementById('map-status').textContent = `Selected ${window._plotSelection.length} songs`;
            // enable/disable song-path button based on selection count
            updateSongPathButtonState();
            // refresh the inline selection panel so users see the change
            try { renderSelectionPanel(); } catch (e) { /* ignore */ }
        });

        gd._amy_handlers_attached = true;
    } catch (e) {
        console.warn('attachPlotHandlers failed', e);
    }
}

// Overlay state: keep backups of overlay shapes so path and highlight overlays
// persist across re-renders. Overlays are always visible by default and only
// cleared by the Refresh/clearMapOverlays action per user's request.
window._mapOverlayShapes = window._mapOverlayShapes || [];
window._mapOverlaysVisible = true;

function registerOverlayShapes(shapes) {
    try {
        window._mapOverlayShapes = window._mapOverlayShapes || [];
        window._mapOverlayShapes.push(...shapes.map(s => Object.assign({}, s)));
    } catch(e) { console.warn('registerOverlayShapes failed', e); }
}

// Toggle helpers: allow hiding/showing overlay shapes by their am_type.
window._am_shapes_saved = window._am_shapes_saved || {};
window._am_show_flags = window._am_show_flags || {};
function _am_toggleShapes(type, btnId, hideLabel, showLabel) {
    try {
        const gd = document.getElementById('plot'); if (!gd) return;
        window._am_shapes_saved = window._am_shapes_saved || {};
        window._am_show_flags = window._am_show_flags || {};
        const key = String(type || '');
        if (window._am_show_flags[key] === undefined) window._am_show_flags[key] = true;
        // hide
        if (window._am_show_flags[key]) {
            const shapes = (gd.layout && Array.isArray(gd.layout.shapes)) ? gd.layout.shapes.slice() : [];
            const keep = [];
            const removed = [];
            for (const s of shapes) {
                try { if (s && s.am_type === key) removed.push(s); else keep.push(s); } catch(e) { keep.push(s); }
            }
            if (removed.length) {
                try { Plotly.relayout(gd, { shapes: keep }).catch(()=>{}); } catch(e) {}
                window._am_shapes_saved[key] = (window._am_shapes_saved[key] || []).concat(removed);
            }
            window._am_show_flags[key] = false;
            try {
                const b = document.getElementById(btnId);
                if (b) {
                    b.classList.add('am-overlay-hidden');
                    try { b.title = showLabel || 'Show'; } catch(e){}
                }
            } catch(e) {}
            return;
        }
        // show
        const toAdd = window._am_shapes_saved[key] || [];
        if (toAdd.length) {
            const existing = (gd.layout && Array.isArray(gd.layout.shapes)) ? gd.layout.shapes.slice() : [];
            const merged = existing.concat(toAdd);
            try { Plotly.relayout(gd, { shapes: merged }).catch(()=>{}); } catch(e) {}
            window._am_shapes_saved[key] = [];
        }
        window._am_show_flags[key] = true;
        try {
            const b = document.getElementById(btnId);
            if (b) {
                b.classList.remove('am-overlay-hidden');
                try { b.title = hideLabel || 'Hide'; } catch(e){}
            }
        } catch(e) {}
    } catch(e) { console.warn('_am_toggleShapes failed', e); }
}
function togglePathPoints(){ _am_toggleShapes('path-point','overlay-toggle-points','Hide pts','Show pts'); }
function togglePathLine(){ _am_toggleShapes('path-line','overlay-toggle-path','Hide path','Show path'); }
function toggleSearchHighlight(){ _am_toggleShapes('search-highlight','overlay-toggle-search','Hide highlight','Show highlight'); }

function updateSongPathButtonState() {
    try {
        const btn = document.getElementById('song-path-btn');
        const count = (window._plotSelection || []).length;
        if (!btn) return;
        btn.disabled = !(count >= 2 && count <= 10);
    } catch (e) { console.warn('updateSongPathButtonState failed', e); }
}

// Append songs (array of objects with id/title/artist) to selection list UI
function appendSongsToSelectionPanel(songs) {
    try {
        window._plotSelection = window._plotSelection || [];
        for (const s of songs) {
            if (!s || !s.item_id) continue;
            const sid = String(s.item_id);
            if (!window._plotSelection.includes(sid)) window._plotSelection.push(sid);
            // ensure minimal metadata is present in _plotPointsFull for display
            window._plotPointsFull = window._plotPointsFull || [];
            if (!window._plotPointsFull.find(p => String(p.id) === sid)) {
                window._plotPointsFull.push({ id: sid, title: s.title || '(unknown)', artist: s.author || s.artist || '', x: (s.embedding_2d && s.embedding_2d[0]) || undefined, y: (s.embedding_2d && s.embedding_2d[1]) || undefined, genre: s.mood_vector ? topGenre(s.mood_vector) : 'unknown' });
            }
        }
        renderSelectionPanel();
    } catch (e) { console.warn('appendSongsToSelectionPanel failed', e); }
}

// Draw a polyline on the map for a path (array of items with embedding_2d or fallback coords)
function drawPathOnMap(pathItems, color) {
    try {
        if (!pathItems || pathItems.length === 0) return;
        const gd = document.getElementById('plot');
        const xs = [];
        const ys = [];
        // Ensure we plot the path in the provided order, attempting multiple fallbacks to find coordinates
        for (const it of pathItems) {
            let x,y;
            if (it.embedding_2d && it.embedding_2d.length >= 2) {
                x = it.embedding_2d[0]; y = it.embedding_2d[1];
            }
            // try common aliases
            if ((x === undefined || y === undefined) && (it.x !== undefined && it.y !== undefined)) {
                x = it.x; y = it.y;
            }
            // fallback to searching plotted points by id
            if ((x === undefined || y === undefined) && it.item_id !== undefined) {
                const found = findPointById(it.item_id) || {};
                if (found && found.x !== undefined && found.y !== undefined) { x = found.x; y = found.y; }
            }
            // as a last resort, try matching by id against _plotPointsFull entries
            if ((x === undefined || y === undefined) && it.item_id !== undefined && window._plotPointsFull) {
                const f = window._plotPointsFull.find(p => String(p.id) === String(it.item_id));
                if (f && f.x !== undefined && f.y !== undefined) { x = f.x; y = f.y; }
            }
            if (x !== undefined && y !== undefined) { xs.push(x); ys.push(y); }
            else {
                // skip points without coordinates but keep order of others
                console.debug('drawPathOnMap skipping point without coords', it && (it.item_id || it.id));
            }
        }
        if (xs.length === 0) return;
        // Build per-point fill colors and hover texts based on genre/title/artist
        const colorMap = window._colorMap || {};
        const fills = [];
        const hovers = [];
        const xs_used = [];
        const ys_used = [];
        // Build synchronized arrays only for points that have coordinates
        for (let i = 0; i < pathItems.length; i++) {
            const it = pathItems[i];
            let x = undefined, y = undefined;
            if (it.embedding_2d && it.embedding_2d.length >= 2) { x = it.embedding_2d[0]; y = it.embedding_2d[1]; }
            if ((x === undefined || y === undefined) && it.x !== undefined && it.y !== undefined) { x = it.x; y = it.y; }
            if ((x === undefined || y === undefined) && it.item_id !== undefined) {
                const found = findPointById(it.item_id) || {};
                if (found && found.x !== undefined && found.y !== undefined) { x = found.x; y = found.y; }
            }
            if ((x === undefined || y === undefined) && it.item_id !== undefined && window._plotPointsFull) {
                const f = window._plotPointsFull.find(p => String(p.id) === String(it.item_id));
                if (f && f.x !== undefined && f.y !== undefined) { x = f.x; y = f.y; }
            }
            if (x === undefined || y === undefined) {
                console.debug('drawPathOnMap skipping point without coords for hover/marker', it && (it.item_id || it.id));
                continue; // skip points without coords for plotting
            }
            xs_used.push(x); ys_used.push(y);

            // determine genre fill
            let genre = null;
            try { if (it.mood_vector) genre = topGenre(it.mood_vector); } catch(e) {}
            if (!genre && it.item_id) {
                const fp = findPointById(it.item_id) || {};
                if (fp && fp.genre) genre = fp.genre;
            }
            if (!genre) genre = 'unknown';
            const fill = colorMap[genre] || color || '#888888';
            fills.push(fill);

            // hover text and displayed step number
            const step = xs_used.length; // order among plotted coords
            const title = (it.title || '') || (findPointById(it.item_id) || {}).title || '(unknown)';
            const artist = (it.artist || it.author) || (findPointById(it.item_id) || {}).artist || '';
            hovers.push(`Step ${step} — [${genre}] ${title} - ${artist}`);

            // ensure metadata present in _plotPointsFull for selection listing
            try {
                if (it.item_id && window._plotPointsFull) {
                    const sid = String(it.item_id);
                    const present = window._plotPointsFull.find(p => String(p.id) === sid);
                    if (!present) {
                        window._plotPointsFull.push({ id: sid, title: title, artist: artist, x: x, y: y, genre: genre });
                    }
                }
            } catch(e) {}
        }

        if (xs_used.length === 0) return;

        // Convert path to layout shapes so it stays on top (layer: 'above') and
        // scales/positions with axis transforms. Build one polyline 'path' shape
        // plus small circle shapes per point so markers are visible like the
        // search highlight.
        try {
            const gd = document.getElementById('plot');
            if (!gd) return;
            // compute radius relative to current axis ranges
            let xRange = null, yRange = null;
            try { xRange = (gd.layout && gd.layout.xaxis && gd.layout.xaxis.range) ? gd.layout.xaxis.range : (gd._fullLayout && gd._fullLayout.xaxis && gd._fullLayout.xaxis.range ? gd._fullLayout.xaxis.range : null); } catch(e) { xRange = null; }
            try { yRange = (gd.layout && gd.layout.yaxis && gd.layout.yaxis.range) ? gd.layout.yaxis.range : (gd._fullLayout && gd._fullLayout.yaxis && gd._fullLayout.yaxis.range ? gd._fullLayout.yaxis.range : null); } catch(e) { yRange = null; }
            // user requested size to be HALF of previous value: 0.015 -> 0.0075, fallback 0.3 -> 0.15
            const rx = (xRange && xRange[1] - xRange[0]) ? (xRange[1] - xRange[0]) * 0.0075 : 0.15;
            const ry = (yRange && yRange[1] - yRange[0]) ? (yRange[1] - yRange[0]) * 0.0075 : 0.15;

            // build SVG path string using data coordinates
            let pathStr = '';
            for (let i = 0; i < xs_used.length; i++) {
                const x = xs_used[i]; const y = ys_used[i];
                if (i === 0) pathStr += `M ${x} ${y}`;
                else pathStr += ` L ${x} ${y}`;
            }

            const pathShape = {
                type: 'path',
                path: pathStr,
                xref: 'x', yref: 'y',
                line: { color: 'black', width: 3 },
                layer: 'above',
                am_type: 'path-line'
            };

            // per-point circle shapes
            const pointShapes = [];
            for (let i = 0; i < xs_used.length; i++) {
                const x = xs_used[i]; const y = ys_used[i];
                const fill = fills[i] || color || '#888888';
                const sh = {
                    type: 'circle', xref: 'x', yref: 'y',
                    x0: x - rx, x1: x + rx, y0: y - ry, y1: y + ry,
                    fillcolor: fill, opacity: 0.95, line: { color: 'black', width: 1.5 }, layer: 'above',
                    am_type: 'path-point'
                };
                pointShapes.push(sh);
            }

            // register shapes so they are restored across re-renders
            try { registerOverlayShapes([pathShape, ...pointShapes]); } catch(e) {}

            // add them immediately to plot layout
            try {
                const existing = (gd.layout && Array.isArray(gd.layout.shapes)) ? gd.layout.shapes.slice() : [];
                const merged = existing.concat([pathShape, ...pointShapes]);
                Plotly.relayout(gd, { shapes: merged }).catch(()=>{});
            } catch(e) { console.warn('drawPathOnMap relayout failed', e); }
        } catch(e) { console.warn('drawPathOnMap failed', e); }
    } catch (e) { console.warn('drawPathOnMap failed', e); }
}

// Remove all path traces and other overlays from the map, keep the main 'tracks' trace intact
function clearMapOverlays() {
    try {
        const gd = document.getElementById('plot');
        if (!gd || !gd.data) return;
        // collect indices of all non-main traces to remove (anything that's not the main 'tracks' trace)
        const removeIdx = [];
        for (let i = 0; i < gd.data.length; i++) {
            const t = gd.data[i];
            if (!t) continue;
            // keep the main tracks trace (name === 'tracks')
            if (String(t.name) === 'tracks') continue;
            removeIdx.push(i);
        }
        if (removeIdx.length > 0) {
            try { Plotly.deleteTraces(gd, removeIdx); } catch(e) { console.warn('Plotly.deleteTraces failed', e); }
        }
        // remove any overlay shapes (highlights) as well
        try { Plotly.relayout(gd, { shapes: [], selections: [] }).catch(()=>{}); } catch(e) {}
        // clear backup overlay state so overlays are fully cleared on Refresh
        try { window._mapOverlayShapes = []; window._mapOverlaysVisible = true; } catch(e) {}
        // clear selection and inline panel
        window._plotSelection = [];
        try { renderSelectionPanel(); } catch(e) { /* ignore */ }
        document.getElementById('map-status').textContent = 'Map refreshed (overlays cleared)';
    } catch (e) { console.warn('clearMapOverlays failed', e); }
}

// Do not attach handlers until a plot is rendered and attachPlotHandlers is called
</script>

<!-- debug button removed per user request -->

<script src="{{ url_for('static', filename='menu.js') }}"></script>
{% endblock %}

{% block postHTMLScripts %}
<script>
        // Improved create-playlist response handling: parse response text safely and surface status
        document.getElementById('create-playlist').onclick = async () => {
            const sel = window._plotSelection || [];
            if (sel.length === 0) { document.getElementById('map-status').textContent = 'No songs selected.'; return; }
            document.getElementById('map-status').textContent = 'Creating playlist...';
            try {
            // filter out any undefined or null ids
            const filtered = (sel || []).filter(id => id !== undefined && id !== null);
            console.debug('Creating playlist with ids', filtered.slice(0,50));
            const payload = { playlist_name: `Map selection ${new Date().toISOString()}`, track_ids: filtered };
            const resp = await fetch("{{ url_for('voyager_bp.create_media_server_playlist') }}", { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
                const text = await resp.text();
                let json = null;
                try { json = text ? JSON.parse(text) : null; } catch(e) { json = null; }
                console.log('create_playlist response', resp.status, text, json);
                if (resp.ok) document.getElementById('map-status').textContent = (json && (json.message || json.playlist_id)) ? (json.message || `Playlist created (${json.playlist_id})`) : 'Playlist created';
                else document.getElementById('map-status').textContent = (json && (json.error || json.message)) ? (json.error || json.message) : `Create playlist failed (${resp.status})`;
                // clear selection on success
                if (resp.ok) window._plotSelection = [];
            } catch (e) {
                console.error('Create playlist failed', e);
                document.getElementById('map-status').textContent = 'Create playlist failed';
            }
        };

            // Song Path button: compute paths between selected songs (consecutive pairs)
            document.getElementById('song-path-btn').onclick = async () => {
                try {
                    const sel = (window._plotSelection || []).slice(0, 10); // cap at 10
                    if (!sel || sel.length < 2) { document.getElementById('map-status').textContent = 'Select at least 2 songs (max 10)'; return; }
                    document.getElementById('map-status').textContent = 'Computing paths...';
                    // For each consecutive pair, call /api/find_path?start_song_id=A&end_song_id=B&max_steps=25
                    const allAppended = [];
                    for (let i = 0; i < sel.length - 1; i++) {
                        const a = sel[i];
                        const b = sel[i+1];
                        const params = new URLSearchParams({ start_song_id: a, end_song_id: b, max_steps: 25 });
                        try {
                            const resp = await fetch(`{{ url_for('path_bp.find_path_endpoint') }}?${params}`);
                            if (!resp.ok) {
                                const err = await resp.json().catch(() => ({}));
                                console.warn('find_path failed for', a, b, err);
                                continue;
                            }
                            const data = await resp.json();
                            if (data && Array.isArray(data.path) && data.path.length > 0) {
                                // append these songs to inspect list and selection
                                appendSongsToSelectionPanel(data.path);
                                // draw the path on the map (use a color per segment)
                                const color = `rgba(${(i*50)%255}, ${(150 + i*30)%255}, ${(200 - i*20 + 255)%255}, 0.85)`;
                                drawPathOnMap(data.path, color);
                                allAppended.push(...data.path.map(p => p.item_id));
                            }
                        } catch (e) {
                            console.warn('Error fetching path for pair', a, b, e);
                        }
                    }
                    document.getElementById('map-status').textContent = `Appended ${allAppended.length} songs from ${sel.length-1} paths`;
                    renderSelectionPanel();
                    updateSongPathButtonState();
                } catch (e) {
                    console.error('song-path failed', e);
                    document.getElementById('map-status').textContent = 'Failed to compute song paths';
                }
            };
</script>
{% endblock %}