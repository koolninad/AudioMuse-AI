{% extends "includes/layout.html" %}

{% block headAdditions %}
<style>
        /* Basic styling for the new checkbox container */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between checkbox and label */
            margin-top: 1rem; /* Align with other inputs */
        }
</style>
{% endblock %}

{% block content %}
<section>
    <header class="page-header">
        <h1>AudioMuse-AI - Playlist from Similar Song</h1>
        <p>Find tracks similar to a given song and create a playlist.</p>
    </header>

    <form id="similarity-form">
        <input type="hidden" id="selected_item_id" name="item_id">
        <div class="param-group">
            <div class="autocomplete-container">
                <label for="artist_search" class="label-with-tooltip">
                    Artist:
                    <span class="info-tooltip" tabindex="0">
                        <span class="info-icon"></span>
                        <span class="tooltip-text">Start typing an artist name to narrow down the song search. This helps find the exact track you're looking for.</span>
                    </span>
                </label>
                <input type="text" id="artist_search" name="artist_search" placeholder="Start typing artist name..." autocomplete="off">
            </div>

            <div class="autocomplete-container">
                <label for="title_search" class="label-with-tooltip">
                    Track Title:
                    <span class="info-tooltip" tabindex="0">
                        <span class="info-icon"></span>
                        <span class="tooltip-text">Type the song name you want to find similar tracks to. As you type, suggestions will appear below.</span>
                    </span>
                </label>
                <input type="text" id="title_search" name="title_search" placeholder="Start typing track title..." autocomplete="off">
                <div id="autocomplete-results" class="autocomplete-results hidden"></div>
            </div>

            <div>
                <label for="n" class="label-with-tooltip">
                    Number of results:
                    <span class="info-tooltip" tabindex="0">
                        <span class="info-icon"></span>
                        <span class="tooltip-text">How many similar songs to find. More results = longer playlist. Typical values: 10-50 songs for a good mix.</span>
                    </span>
                </label>
                <input type="number" id="n" name="n" value="10" min="1" max="200">
            </div>
        </div>
        <div class="param-group">
            <div class="checkbox-container">
                <input type="checkbox" id="eliminate_duplicates" name="eliminate_duplicates" checked>
                <label for="eliminate_duplicates" class="label-with-tooltip">
                    Limit songs per artist in results
                    <span class="info-tooltip" tabindex="0">
                        <span class="info-icon"></span>
                        <span class="tooltip-text">Prevents the playlist from being dominated by one artist. When enabled, limits how many tracks from the same artist can appear in results.</span>
                    </span>
                </label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="radius_similarity" name="radius_similarity" checked>
                <label for="radius_similarity" class="label-with-tooltip">
                    Radius Similarity
                    <span class="info-tooltip" tabindex="0">
                        <span class="info-icon"></span>
                        <span class="tooltip-text">Groups similar songs into "buckets" and orders them for better listening flow. Recommended for smoother transitions between tracks.</span>
                    </span>
                </label>
            </div>
            <!--<div class="checkbox-container">
                <input type="checkbox" id="mood_similarity" name="mood_similarity">
                <label for="mood_similarity">Filter by mood similarity (danceability, energy, etc.)</label>
            </div>-->
        </div>
        <button type="submit">
            Find Similar Tracks
        </button>
    </form>
</section>

<section id="results-container" class="hidden">
    <h2>Results</h2>
    <div id="max-distance" style="font-weight:600; margin-bottom:0.5rem;"></div>
    <div id="status"></div>
    <!-- Graph visualization removed (not needed) -->
    <div id="results-table-wrapper"></div>
</section>

<section id="playlist-creator" class="hidden">
    <h3>Create a Playlist from Results</h3>
    <form id="playlist-form">
        <div class="param-group">
            <div>
                <label for="playlist_name">Playlist Name:</label>
                <input type="text" id="playlist_name" name="playlist_name" required placeholder="e.g., My Awesome Mix">
            </div>
        </div>
        <!-- MODIFIED: Changed button text to be more generic -->
        <button type="submit" style="background-color: #16A34A;">
            Create Playlist on Media Server
        </button>
    </form>
    <div id="playlist-status"></div>
</section>
{% endblock %}

{% block bodyAdditions %}
    <script>
        (() => {
            let currentTrackIds = [];
            let currentTracks = [];
            let searchTimeout;

            const similarityForm = document.getElementById('similarity-form');
            const playlistForm = document.getElementById('playlist-form');
            const artistInput = document.getElementById('artist_search');
            const titleInput = document.getElementById('title_search');
            const selectedItemIdInput = document.getElementById('selected_item_id');
            const autocompleteResults = document.getElementById('autocomplete-results');
            const resultsContainer = document.getElementById('results-container');
            const playlistCreator = document.getElementById('playlist-creator');
            const statusDiv = document.getElementById('status');
            const resultsTableWrapper = document.getElementById('results-table-wrapper');
            const playlistStatusDiv = document.getElementById('playlist-status');

            // --- Autocomplete Logic ---
            const handleSearchInput = () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(async () => {
                    const artistQuery = artistInput.value.trim();
                    const titleQuery = titleInput.value.trim();

                    if (artistQuery.length < 3 && titleQuery.length < 3) {
                        hideAutocomplete();
                        return;
                    }

                    try {
                        const params = new URLSearchParams({ artist: artistQuery, title: titleQuery });
                        const response = await fetch(`{{ url_for('voyager_bp.search_tracks_endpoint') }}?${params}`);
                        const tracks = await response.json();
                        showAutocomplete(tracks);
                    } catch (error) {
                        console.error('Autocomplete search error:', error);
                        hideAutocomplete();
                    }
                }, 300); // Debounce requests by 300ms
            };

            const showAutocomplete = (tracks) => {
                autocompleteResults.innerHTML = '';
                if (tracks.length === 0) {
                    autocompleteResults.innerHTML = '<div class="autocomplete-item"><em>No results found</em></div>';
                } else {
                    tracks.forEach(track => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'autocomplete-item';
                        itemDiv.innerHTML = '<div class="title">' + track.title + '</div><div class="artist">' + track.author + '</div>';
                        itemDiv.addEventListener('click', () => selectTrack(track));
                        autocompleteResults.appendChild(itemDiv);
                    });
                }
                autocompleteResults.classList.remove('hidden');
            };

            const hideAutocomplete = () => {
                autocompleteResults.classList.add('hidden');
            };

            const selectTrack = (track) => {
                artistInput.value = track.author;
                titleInput.value = track.title;
                selectedItemIdInput.value = track.item_id;
                hideAutocomplete();
            };

            artistInput.addEventListener('input', handleSearchInput);
            titleInput.addEventListener('input', handleSearchInput);
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.autocomplete-container')) {
                    hideAutocomplete();
                }
            });

            // Graph visualization removed — kept UI and results table only.

            // --- Main Form Submission ---
            similarityForm.addEventListener('submit', async function (event) {
                event.preventDefault();

                const itemId = selectedItemIdInput.value;
                const n = document.getElementById('n').value;
                const eliminateDuplicates = document.getElementById('eliminate_duplicates').checked;
                const radiusSimilarity = document.getElementById('radius_similarity').checked;
                // Mood similarity removed from UI/API: do not read or send this value
                // const moodSimilarity = document.getElementById('mood_similarity').checked;

                resultsContainer.classList.remove('hidden');
                playlistCreator.classList.add('hidden');
                statusDiv.textContent = 'Searching...';
                statusDiv.className = '';
                resultsTableWrapper.innerHTML = '';

                if (!itemId) {
                    statusDiv.textContent = 'Please select a track from the autocomplete suggestions.';
                    statusDiv.className = 'status-error';
                    return;
                }

                try {
                    const params = new URLSearchParams({
                        item_id: itemId,
                        n: n,
                        eliminate_duplicates: eliminateDuplicates, // Always send true or false
                        radius_similarity: radiusSimilarity
                        // mood_similarity intentionally omitted
                    });
                    const response = await fetch(`{{ url_for('voyager_bp.get_similar_tracks_endpoint') }}?${params}`);
                    const data = await response.json();

                    if (!response.ok) throw new Error(data.error || `HTTP error! status: ${response.status}`);

                    if (data.length === 0) {
                        statusDiv.textContent = 'No similar tracks found.';
                        return;
                    }

                    // Fetch exact max distance for the selected song and display it.
                    // Also fetch the farthest song's title/artist when the API returns a farthest_item_id.
                    try {
                        const mdResp = await fetch(`{{ url_for('voyager_bp.get_max_distance_endpoint') }}?item_id=` + encodeURIComponent(itemId));
                        if (mdResp.ok) {
                            const md = await mdResp.json();
                            const maxDistDiv = document.getElementById('max-distance');
                            if (md && typeof md.max_distance === 'number') {
                                // Default text with just the distance
                                let text = 'Max distance: ' + md.max_distance.toFixed(4);

                                // If server returned the farthest item's id, try to fetch its title/artist
                                const farId = md.farthest_item_id || md.farthest_id || md.item_id || md.max_item_id || md.farthestItemId;
                                if (farId) {
                                    try {
                                        const tdResp = await fetch(`{{ url_for('voyager_bp.get_track_endpoint') }}?item_id=` + encodeURIComponent(farId));
                                        if (tdResp.ok) {
                                            const td = await tdResp.json();
                                            if (td && (td.title || td.author)) {
                                                const title = td.title || 'Unknown title';
                                                const author = td.author || 'Unknown artist';
                                                text += ' — Farthest track: "' + title + '" by ' + author;
                                            } else {
                                                // If the endpoint returned something unexpected, show the id
                                                text += ' — Farthest track ID: ' + farId;
                                            }
                                        } else {
                                            // If the track endpoint failed, show the id only
                                            text += ' — Farthest track ID: ' + farId;
                                        }
                                    } catch (errInner) {
                                        console.error('Failed to fetch farthest track metadata:', errInner);
                                        text += ' — Farthest track ID: ' + farId;
                                    }
                                }

                                maxDistDiv.textContent = text;
                            } else {
                                maxDistDiv.textContent = '';
                            }
                        }
                    } catch (err) {
                        console.error('Failed to fetch max distance:', err);
                    }

                    currentTrackIds = [itemId, ...data.map(track => track.item_id)];

                    currentTracks = [{id: itemId, title: titleInput.value, author: artistInput.value}, ...data.map(track => ({id: track.item_id, title: track.title, author: track.author}))];

                    // Graph visualization removed: skipping map fetch and chart rendering.

                    statusDiv.textContent = 'Found ' + data.length + ' similar tracks.';
                    const tableHTML = '<table><thead><tr><th>Title</th><th>Artist</th><th>Distance</th></tr></thead><tbody>' + data.map(track => '<tr><td>' + (track.title || 'N/A') + '</td><td>' + (track.author || 'N/A') + '</td><td>' + track.distance.toFixed(4) + '</td></tr>').join('') + '</tbody></table>';
                    resultsTableWrapper.innerHTML = tableHTML;
                    playlistCreator.classList.remove('hidden');
                    playlistStatusDiv.textContent = '';
                    document.getElementById('playlist_name').value = "Similar to " + titleInput.value;

                } catch (error) {
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.className = 'status-error';
                    console.error('Fetch error:', error);
                }
            });

            // --- Playlist Creation ---
            playlistForm.addEventListener('submit', async function (event) {
                event.preventDefault();
                const playlistName = document.getElementById('playlist_name').value;

                playlistStatusDiv.className = '';
                if (!playlistName) {
                    playlistStatusDiv.textContent = 'Please enter a playlist name.';
                    playlistStatusDiv.className = 'status-error';
                    return;
                }
                if (currentTrackIds.length === 0) {
                    playlistStatusDiv.textContent = 'No tracks to add. Please perform a search first.';
                    playlistStatusDiv.className = 'status-error';
                    return;
                }
                playlistStatusDiv.textContent = 'Creating playlist...';

                try {
                    const response = await fetch("{{ url_for('voyager_bp.create_media_server_playlist') }}", {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playlist_name: playlistName,
                            track_ids: currentTrackIds
                        }),
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    playlistStatusDiv.textContent = result.message;
                    playlistStatusDiv.className = 'status-success';
                } catch (error) {
                    playlistStatusDiv.textContent = `Error: ${error.message}`;
                    playlistStatusDiv.className = 'status-error';
                    console.error('Playlist creation error:', error);
                }
            });
        })();
    </script>
    <script src="{{ url_for('static', filename='menu.js') }}"></script>
{% endblock %}